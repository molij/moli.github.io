<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.121.2">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>PHP设计模式之单例模式 &middot; 莫离君的博客</title>
  <meta name="description" content="PHP设计模式之单例模式" />

  
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://gongvirgil.github.io/Blog/"><h1>莫离君的博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://gongvirgil.github.io/Blog/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2024. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>PHP设计模式之单例模式</h1>
  <time datetime=2015-10-09T00:00:00Z class="post-date">Fri, Oct 9, 2015</time>
  <p>单例模式（职责模式）：</p>
<p>简单的说，一个对象（在学习设计模式之前，需要比较了解面向对象思想）只负责一个特定的任务；</p>
<!-- raw HTML omitted -->
<p>单例类：</p>
<p>1、构造函数需要标记为private（访问控制：防止外部代码使用new操作符创建对象），单例类不能在其他类中实例化，只能被其自身实例化；</p>
<p>2、拥有一个保存类的实例的静态成员变量</p>
<p>3、拥有一个访问这个实例的公共的静态方法（常用getInstance()方法进行实例化单例类，通过instanceof操作符可以检测到类是否已经被实例化）</p>
<p>另外，需要创建__clone()方法防止对象被复制（克隆）</p>
<p>为什么要使用PHP单例模式？</p>
<p>1、php的应用主要在于数据库应用, 所以一个应用中会存在大量的数据库操作, 使用单例模式, 则可以避免大量的new 操作消耗的资源。</p>
<p>2、如果系统中需要有一个类来全局控制某些配置信息, 那么使用单例模式可以很方便的实现. 这个可以参看ZF的FrontController部分。</p>
<p>3、在一次页面请求中, 便于进行调试, 因为所有的代码(例如数据库操作类db)都集中在一个类中, 我们可以在类中设置钩子, 输出日志，从而避免到处var_dump, echo。</p>
<p>代码实现：</p>
<pre><code>&lt;?php

/*

* 设计模式之单例模式

* $_instance必须声明为静态的私有变量

* 构造函数和析构函数必须声明为私有,防止外部程序new

* 类从而失去单例模式的意义

* getInstance()方法必须设置为公有的,必须调用此方法

* 以返回实例的一个引用

* ::操作符只能访问静态变量和静态函数

* new对象都会消耗内存

* 使用场景:最常用的地方是数据库连接。 

* 使用单例模式生成一个对象后，

* 该对象可以被其它众多对象所使用。 

*/

class Danli {

 

//保存类实例的静态成员变量

private static $_instance;

 

//private标记的构造方法

private function __construct(){

echo 'This is a Constructed method;';

}

 

//创建__clone方法防止对象被复制克隆

public function __clone(){

trigger_error('Clone is not allow!',E_USER_ERROR);

}

 

//单例方法,用于访问实例的公共的静态方法

public static function getInstance(){

if(!(self::$_instance instanceof self)){

self::$_instance = new self;

}

return self::$_instance;

}

 

public function test(){

echo '调用方法成功';

}

 

}

 

//用new实例化private标记构造函数的类会报错

//$danli = new Danli();

 

//正确方法,用双冒号::操作符访问静态方法获取实例

$danli = Danli::getInstance();

$danli-&gt;test();

 

//复制(克隆)对象将导致一个E_USER_ERROR

$danli_clone = clone $danli; </code></pre>

</div>


    </main>

    
      
    
  </body>
</html>
