<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.121.2">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>莫离君的博客</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://gongvirgil.github.io/Blog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://gongvirgil.github.io/Blog/index.xml" rel="alternate" type="application/rss+xml" title="莫离君的博客" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://gongvirgil.github.io/Blog/"><h1>莫离君的博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://gongvirgil.github.io/Blog/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2024. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/llm/2024-06-18-learn-lang-chain/">手把手教你认识学会LangChain</a>
  </h1>
  <time datetime="2024-06-18T00:00:00Z" class="post-date">Tue, Jun 18, 2024</time>
  什么是LangChain LangChain: 一个让你的LLM变得更强大的开源框架。LangChain 就是一个 LLM 编程框架，你想开发一个基于 LLM 应用，需要什么组件它都有，直接使用就行；甚至针对常规的应用流程，它利用链(LangChain中Chain的由来)这个概念已经内置标准化方案了。下面我们从新兴的大语言模型（LLM）技术栈的角度来看看为何它的理念这么受欢迎。
LangChain起源 LangChain 的作者是 Harrison Chase，最初是于 2022 年 10 月开源的一个项目，在 GitHub 上获得大量关注之后迅速转变为一家初创公司。2017 年 Harrison Chase 还在哈佛上大学，如今已是硅谷的一家热门初创公司的 CEO，这对他来说是一次重大而迅速的跃迁。Insider 独家报道，人工智能初创公司 LangChain 在种子轮一周后，再次获得红杉领投的 2000 万至 2500 万美元融资，估值达到 2 亿美元。
LangChain六大主要领域 管理和优化prompt。不同的任务使用不同prompt，如何去管理和优化这些prompt是langchain的主要功能之一。 链，初步理解为一个具体任务中不同子任务之间的一个调用。 数据增强的生成，数据增强生成涉及特定类型的链，它首先与外部数据源交互以获取数据用于生成步骤。这方面的例子包括对长篇文字的总结和对特定数据源的提问/回答。 代理，根据不同的指令采取不同的行动，直到整个流程完成为止。 评估，生成式模型是出了名的难以用传统的指标来评估。评估它们的一个新方法是使用语言模型本身来进行评估。LangChain提供了一些提示/链来协助这个工作。 内存：在整个流程中帮我们管理一些中间状态。 总的来说LangChain可以理解为：在一个流程的整个生命周期中，管理和优化prompt，根据prompt使用不同的代理进行不同的动作，在这期间使用内存管理中间的一些状态，然后使用链将不同代理之间进行连接起来，最终形成一个闭环。
LangChain的主要价值组件 组件：用于处理语言模型的抽象概念，以及每个抽象概念的实现集合。无论你是否使用LangChain框架的其他部分，组件都是模块化的，易于使用。
现成的链：用于完成特定高级任务的组件的结构化组合。现成的链使人容易上手。对于更复杂的应用和细微的用例，组件使得定制现有链或建立新链变得容易。
LangChain组件 model I/O：语言模型接口 data connection：与特定任务的数据接口 chains：构建调用序列 agents：给定高级指令，让链选择使用哪些工具 memory：在一个链的运行之间保持应用状态 callbacks：记录并流式传输任何链的中间步骤 indexes：索引指的是结构化文件的方法，以便LLM能够与它们进行最好的交互 数据连接组件data connection LLM应用需要用户特定的数据，这些数据不属于模型的训练集。LangChain通过以下方式提供了加载、转换、存储和查询数据的构建模块：
文档加载器：从许多不同的来源加载文档 文档转换器：分割文档，删除多余的文档等 文本嵌入模型：采取非结构化文本，并把它变成一个浮点数的列表 矢量存储：存储和搜索嵌入式数据 检索器：查询你的数据
data connection整体流程 data connection——文档加载器 python安装包命令：
pip install langchain pip install unstructured pip install jq CSV基本用法 import os from pathlib import Path from langchain.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/llm/2024-06-18-learn-lang-chain/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/llm/2024-06-18-text-to-vec/">文本向量化</a>
  </h1>
  <time datetime="2024-06-18T00:00:00Z" class="post-date">Tue, Jun 18, 2024</time>
  一、文本向量化 文本向量化：将文本信息表示成能够表达文本语义的向量，是用数值向量来表示文本的语义。
词嵌入(Word Embedding)：一种将文本中的词转换成数字向量的方法，属于文本向量化处理的范畴。
向量嵌入操作面临的挑战包括：
信息丢失：向量表达需要保留信息结构和节点间的联系。 可扩展性：嵌入方法应具有可扩展性，能够处理可变长文本信息。 维数优化：高维数会提高精度，但时间和空间复杂性也被放大。低维度虽然时间、空间复杂度低，但以损失原始信息为代价，因此需要权衡最佳维度的选择。 常见的文本向量和词嵌入方法包括独热模型（One Hot Model），词袋模型（Bag of Words Model）、词频-逆文档频率（TF-IDF）、N元模型（N-Gram）、单词-向量模型（Word2vec）、文档-向量模型（Doc2vec）
二、独热编码 One-hot编码采用N位状态寄存器来对N个状态进行编码，是分类变量作为二进制向量的表述。
首先根据提供的文本构建词典，其中的数字可以视作对应词语的标签信息或者事物的分类信息。
然后基于独热编码表达法，构造一个N维向量，该向量的维度与词典的长度一直，对于给定词语进行向量表达时，其在词典中出现的响应位置的寄存器赋值为1，其余为0示例如下：
三、词袋模型 词袋模型(Bag-of-words model：BOW)假定对于给定文本，忽略单词出现的顺序和语法等因素，将其视为词汇的简单集合，文档中每个单词的出现属于独立关系，不依赖于其它单词。先将句子向量化，句子维度和字典维度一致，第 i 维上的数字代表 ID 为 i 的词语在该句子里出现的频率。
四、词频-逆文档频率模型 TF-IDF（term frequency-inverse document frequency）是数据信息挖掘的常用统计技术。TF(Term Frequency)中文含义是词频，IDF(Inverse Document Frequency)中文含义是逆文本频率指数。
词频统计的是词语在特定文档中出现的频率，而逆文档频率统计的是词语在其他文章中出现的频率，其处理基本逻辑是词语的重要性随着其在特定文档中出现的次数呈现递增趋势，但同时会随着其在语料库中其他文档中出现的频率递减下降 数学表达式如下：
五、N元模型 N-Gram语言模型基本思路是基于给定文本信息，预测下一个最可能出现的词语。N=1称为unigram，表示下一词的出现不依赖于前面的任何词；N=2称为bigram，表示下一词仅依赖前面紧邻的一个词语，依次类推。
六、单词-向量模型 将不可计算、非结构化的词语转化为可计算、结构化的向量。word2vec模型假设不关注词的出现顺序。Word2Vec包含连续词袋模型CBOW（Continues Bag of Words）和Skip-gram模型两种网络结构。训练完成之后，模型可以针对词语和向量建立映射关系，因此可用来表示词语跟词语之间的关系
CBOW模型如下：
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2018-05-25-cron-session-log/">session opened/closed for user root by (uid=0)</a>
  </h1>
  <time datetime="2018-05-25T00:00:00Z" class="post-date">Fri, May 25, 2018</time>
  服务器出现大量这种日志使得 /var/ 目录占用磁盘空间巨大：
# tail -f /var/log/auth.log May 25 14:40:01 1204developer CRON[2191]: pam_unix(cron:session): session opened for user www-data by (uid=0) May 25 14:40:01 1204developer CRON[2193]: pam_unix(cron:session): session opened for user www-data by (uid=0) May 25 14:40:01 1204developer CRON[2192]: pam_unix(cron:session): session opened for user www-data by (uid=0) May 25 14:40:01 1204developer CRON[2192]: pam_unix(cron:session): session closed for user www-data May 25 14:40:01 1204developer CRON[2190]: pam_unix(cron:session): session closed for user www-data May 25 14:40:01 1204developer CRON[2191]: pam_unix(cron:session): session closed for user www-data May 25 14:41:01 1204developer CRON[2189]: pam_unix(cron:session): session closed for user smmsp May 25 14:41:01 1204developer CRON[12928]: pam_unix(cron:session): session opened for user www-data by (uid=0) May 25 14:41:02 1204developer CRON[12928]: pam_unix(cron:session): session closed for user www-data May 25 14:41:09 1204developer CRON[2193]: pam_unix(cron:session): session closed for user www-data 解决方案：
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/linux/2018-05-25-cron-session-log/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-07-17-anonymous-function/">PHP代码之使用匿名函数</a>
  </h1>
  <time datetime="2017-07-17T00:00:00Z" class="post-date">Mon, Jul 17, 2017</time>
  匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。
匿名函数目前是通过Closure类来实现的。
闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类Closure的对象实例。把一个closure对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号。
闭包可以从父作用域中继承变量。 任何此类变量都应该用use语言结构传递进去。 PHP 7.1起，不能传入此类变量：superglobals、 $this 或者和参数重名。 这些变量都必须在函数或类的头部声明。 从父作用域中继承变量与使用全局变量是不同的。全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而 闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。
构建函数或方法内部的代码块 假如我们有一段逻辑，在一个函数或者方法里我们需要格式化数据,但是这个格式化数据的代码片段出现了多次，如果我们直接写可能会想下面这样：
function doSomething(...) { ... // 格式化代码段 ... ... // 格式化代码段[重复的代码] ... } 我相信大多数的人应该不会像上面这么写，可能都会像下面这样：
function doSomething(...) { ... format(...); ... format(...); ... } // 再声明一个格式花代码的函数或方法 function format() { // 格式化代码段 ... } 上面这样的写法没有任何的问题，最小单元化我们的代码片段，但是如果这个format函数或者方法只是doSomething使用呢？我通常会向下面这么写，为什么？因为我认为在这种上下文的环境中format和doSomething的一个子集。
function doSomething() { ... $package = function (...) use (...) {　// 同样use后面的参数也可以传引用 // 格式化代码段 ... }; ... package(...); ... package(...); .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-07-17-anonymous-function/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-07-17-use-/">PHP代码之使用引用</a>
  </h1>
  <time datetime="2017-07-17T00:00:00Z" class="post-date">Mon, Jul 17, 2017</time>
  在PHP 中引用的意思是：不同的名字访问同一个变量内容。php的引用（就是在变量或者函数、对象等前面加上&amp;符号）最重要就是删除引用的变量，只是引用的变量访问不了，但是内容并没有销毁。
场景一：遍历一个数组获取新的数据结构 也许你会这样写：
// 申明一个新的数组,组装成你想要的数据 $tmp = []; foreach ($arr as $k =&gt; $v) { // 取出你想要的数据 $tmp[$k]['youwant'] = $v['youwant']; ... // 一系列判断得到你想要的数据 if (...) { $tmp[$k]['youwantbyjudge'] = 'TIGERB'; } ... } // 最后得要你想要的数组$tmp ------------------------------------------------------- // 也许你觉着上面的写法不是很好，那我们下面换种写法 foreach ($arr as $k =&gt; $v) { // 一系列判断得到你想要的数据 if (...) { // 复写值为你想要的 $arr[$k]['youwantbyjudge'] = 'TIGERB' } ... // 干掉你不想要的结构 unset($arr[$k]['youwantdel']); } // 最后我们得到我们的目标数组$arr 接下来我们使用引用值：
foreach ($arr as ＆$v) { // 一系列判断得到你想要的数据 if (.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-07-17-use-/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-07-17-interface/">PHP类的接口`interface`</a>
  </h1>
  <time datetime="2017-07-17T00:00:00Z" class="post-date">Mon, Jul 17, 2017</time>
  PHP类是单继承，也就是不支持多继承，当一个类需要多个类的功能时，继承就无能为力了，为此 PHP 引入了类的接口技术。
如果一个抽象类里面的所有方法都是抽象方法，且没有声明变量，而且接口里面所有的成员都是public权限的，那么这种特殊的抽象类就叫接口。
接口使用关键字interface来定义，并使用关键字implements来实现接口中的方法，且必须完全实现。
例子：
&lt;?php //定义接口 interface User{ function getDiscount(); function getUserType(); } //VIP用户 接口实现 class VipUser implements User{ // VIP 用户折扣系数 private $discount = 0.8; function getDiscount() { return $this-&gt;discount; } function getUserType() { return &quot;VIP用户&quot;; } } class Goods{ var $price = 100; var $vc; //定义 User 接口类型参数，这时并不知道是什么用户 function run(User $vc){ $this-&gt;vc = $vc; $discount = $this-&gt;vc-&gt;getDiscount(); $usertype = $this-&gt;vc-&gt;getUserType(); echo $usertype.&quot;商品价格：&quot;.$this-&gt;price*$discount; } } $display = new Goods(); $display -&gt;run(new VipUser);	//可以是更多其他用户类型 ?
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-07-17-interface/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-06-23-composer-exceeded-time/">Composer错误：exceeded the timeout of 300 seconds</a>
  </h1>
  <time datetime="2017-06-23T00:00:00Z" class="post-date">Fri, Jun 23, 2017</time>
  Symfony2在使用Composer安装phpunit的时候遇到下面的错误：
[Symfony\Component\Process\Exception\ProcessTimedOutException] The process &quot;git clone --no-checkout 'https://github.com/sebastianbergmann/phpunit.git' '/home/cxl/tp5-project/vendor/phpunit/phpunit' &amp;&amp; cd '/home/cxl/tp5-project/vendor/phpunit/phpunit' &amp;&amp; git remote add composer 'https://github.com/sebastianbergmann/phpunit.git' &amp;&amp; git fetch composer&quot; exceeded the timeout of 300 seconds. 解决方案：增加COMPOSER_PROCESS_TIMEOUT，执行命令如下：
//查看默认超时时间 composer config --list //设置超时时间 composer config -g process-timeout 600 //清除缓存 composer clear-cache 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-06-13-switch-between-multiple-php-version-on-ubuntu/">Ubuntu上在多个PHP版本之间切换</a>
  </h1>
  <time datetime="2017-06-13T00:00:00Z" class="post-date">Tue, Jun 13, 2017</time>
  在您的系统上，如果您已安装了多个版本的PHP（例如PHP 7.1和PHP 5.6两者）。 PHP 7.1作为Apache和CLI的默认PHP运行。对于任何需求，您需要使用PHP 5.6。然后你不需要删除php 7.1。你可以简单地切换php版本为默认用于Apache和命令行。
例如，您的服务器安装了PHP 7.1和PHP 5.6两个版本。现在下面的例子将帮助你在两个版本之间切换。
从PHP 5.6 =&gt; PHP 7.1 默认PHP 5.6在您的系统上设置，您需要切换到PHP 7.1。
Apache： – $ sudo a2dismod php5.6 $ sudo a2enmod php7.1 $ sudo service apache2 restart 命令行：- $ update-alternatives --set php /usr/bin/php7.1 从PHP 7.1 =&gt; PHP 5.6 默认PHP 7.1在您的系统上设置，您需要切换到PHP 5.6。
Apache： – $ sudo a2dismod php7.1 $ sudo a2enmod php5.6 $ sudo service apache2 restart 命令行：- $ sudo update-alternatives --set php /usr/bin/php5.6 原文地址：如何在Ubuntu上在多个PHP版本之间切换
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2017-04-01-php-recursion-memory-problem/">递归时内存占用问题</a>
  </h1>
  <time datetime="2017-04-01T00:00:00Z" class="post-date">Sat, Apr 1, 2017</time>
  若有涉及到重复操作，尽量使用循环而非递归。 每一次递归调用都将过程在内存中复制一遍，如果有大数据的局部变量则会导致内存激增。 内存分配的图示：
&lt;?php //递归10次内存测试 function test($j=0,$start){ $aa = str_repeat($j,2560000); echo (memory_get_usage()-$start).&#34;\r\n&#34;;//依次输出：2560424 5120704 7680920 10241136 12801352 15361568 17921784 20482000 23042216 25602432 //结论：递归自身之前需要unset局部变量释放内存，否则会一直占据内存直到递归结束 $j++; if($j&lt;10) test($j,$start); } function test1($j=0,$start){ $queue = array(); array_push($queue, $j); while(count($queue)&lt;10){ $aa = str_repeat($j,2560000); echo (memory_get_usage()-$start).&#34;\r\n&#34;;//依次输出：2560856 2561120 2561320 2561520 2561720 2561920 2562120 2562320 2562584 $j++; array_push($queue, $j); } } $start = memory_get_usage(); test(0,$start); ?&gt; 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/mysql/2016-11-22-ubuntu-mysql-connect/">解决Ubuntu远程连接mysql连不上的问题</a>
  </h1>
  <time datetime="2016-11-22T00:00:00Z" class="post-date">Tue, Nov 22, 2016</time>
  原因：Ubuntu竟然在mysql的配置文件中默认绑定了本机。
解决方案：果断给注释掉。编辑配置文件/etc/mysql/my.cnf，注释掉里边的bind-address配置项。
# Instead of skip-networking the default is now to listen only on # localhost which is more compatible and is not less secure. bind-address = 127.0.0.1 重启mysql
service mysql restart 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2016-11-01-shell-dos-fault/">Linux下执行shell提示错误syntax error:unexpected end of file</a>
  </h1>
  <time datetime="2016-11-01T00:00:00Z" class="post-date">Tue, Nov 1, 2016</time>
  因为开发环境是虚拟机Linux系统，开发时映射到Windows系统，所以在Windows系统下编辑的shell脚本，在执行时发现提示错误syntax error:unexpected end of file。
原因是DOS下文件和Linux下文件格式差异。DOS下的断行标志是\r\n，对应十六进制为0D 0A。而Unix下的断行标志是\n，十六进制为0A。
换句话说，在Windows系统下，换行用的两个符号：回车\r、换行\n，在Linux下只有一个\n。
DOS格式的文本文件在Linux下，有时候vi打开时行尾会显示^M，当然也有可能看不到，但是在vi界面会在下方显示该文件格式，如&quot;test.txt&quot; [dos] 9L, 113C，可以看出该文件是DOS格式。
解决方法 在Linux下vi编辑执行如下命令即可：
vi test.txt :set fileformat=unix :wq 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2016-09-29-mbp-router-wifi/">Macbook pro连接无线路由不稳定掉线的解决办法</a>
  </h1>
  <time datetime="2016-09-29T00:00:00Z" class="post-date">Thu, Sep 29, 2016</time>
  原因 你和你邻居无线路由之间的&quot;信道&quot;相互冲突 &ldquo;频段带宽&quot;过低，穿墙能力不强 无线信号&quot;模式&quot;过于老旧 当无线路由&quot;模式&quot;选项选择为&quot;自动&quot;时，有第二个无线设备试图接入无线网络时，如果第二个接入设备的无线模块陈旧，无线路由器会自动适配陈旧的发射模式 无线信号&quot;最大发射速率&quot;太低 解决方法 进入路由器管理界面，以TP-LINK为例，进入192.168.1.1管理界面，更改无线设置的基本设置项：
&ldquo;信道&quot;改为&quot;9&rdquo;（无线路由自动默认的信道一般是1，3，4，6）改为&quot;9&quot;一般不会和其他路由冲突，不容易掉线。（重要） &ldquo;模式&quot;改为&quot;11n only&rdquo; &ldquo;频段带宽&quot;改为&quot;40MHz&rdquo; &ldquo;最大发射功率&quot;改为最大（一般是300Mbps或者150Mbps） 保存后，自动重启生效即可。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-05-11-ajax-cross-domain-with-cookies/">Ajax跨域请求带上cookies</a>
  </h1>
  <time datetime="2016-05-11T00:00:00Z" class="post-date">Wed, May 11, 2016</time>
  跨域允许 远端设置 Access-Control-Allow-Origin &ldquo;*&rdquo;
Ajax请求跨域带上cookies 本地设置 withCredentials = true; 远端设置 Access-Control-Allow-Credentials true
Access-Control-Allow-Credentials 为 true 时，Access-Control-Allow-Origin不能同时为 *，不然会报跨错误，需要单独配置跨域准许。
** jQuery中Ajax写法： **
$.ajax({ url: a_cross_domain_url, xhrFields: { withCredentials: true } }); 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/git/2016-04-14-git-bash-change-initial-directory/">Git Bash 更改初始目录</a>
  </h1>
  <time datetime="2016-04-14T00:00:00Z" class="post-date">Thu, Apr 14, 2016</time>
  每次打开Git Bash时，默认的初始目录是/c/Windows/system,切换工作目录还需要手动敲cd /../..，太过麻烦。
右键点击Git Bash启动项，打开属性，找到快捷方式的起始位置一栏，改为自己的工作目录路径就可以了。
如图所示：
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2016-04-14-skype-port-80/">Skype打开默认占用80端口问题</a>
  </h1>
  <time datetime="2016-04-14T00:00:00Z" class="post-date">Thu, Apr 14, 2016</time>
  因为新工作需要使用Skype来交流，才发现Skype打开时默认占用80端口和443端口，导致Apache无法启动。
解决方法很简单，在Skype的设置里面，找到&quot;工具-&gt;选项-&gt;高级-&gt;连接&quot;，将端口80和端口443用于其他接入连接 前去掉勾选，就可以了。
如图所示：
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E8%8D%89%E7%A8%BF/2016-03-30-some-questions-met/">面试中遇到的一些问题总结</a>
  </h1>
  <time datetime="2016-03-30T00:00:00Z" class="post-date">Wed, Mar 30, 2016</time>
  Linux 常用的一些命令 cd ls grep find cp/mv/rm ps kill file tar cat chgrp/chown/chmod vim time df mysql 数据库的索引认知 http://www.tuicool.com/articles/ZRN3qu
PHP的MVC实现原理分析 MVC三个字母的含义： M：Model 模型，负责数据库操作。 V：View 视图，负责调用Model调取数据，再调用模板，展示出最终效果。 C：Controller 控制器，程序的入口，决定改调用哪个View，并告诉View该做什么。 下面是一个超级简单的MVC结构实现：
Controller.php include 'Model.php'; include 'View.php'; class Controller { private $model = ''; private $view = ''; public function Controller(){ $this-&gt;model = new Model(); $this-&gt;view = new View(); } public function doAction( $method = 'defaultMethod', $params = array() ){ if( empty($method) ){ $this-&gt;defaultMethod(); }else if( method_exists($this, $method) ){ call_user_func(array($this, $method), $params); }else{ $this-&gt;nonexisting_method(); } } public function link_page($name = ''){ $links = $this-&gt;model-&gt;getLinks(); $this-&gt;view-&gt;display($links); $result = $this-&gt;model-&gt;getResult($name); $this-&gt;view-&gt;display($result); } public function defaultMethod(){ $this-&gt;br(); echo &quot;This is the default method.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E8%8D%89%E7%A8%BF/2016-03-30-some-questions-met/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E8%8D%89%E7%A8%BF/2016-03-29-svn-git-diff/">svn与git的一些区别</a>
  </h1>
  <time datetime="2016-03-29T00:00:00Z" class="post-date">Tue, Mar 29, 2016</time>
  git是分布式的，svn不是 内容存储方式，git是按元数据，svn是按文件 分支不同 git没有一个全局版本号，svn有 git内容完整性要优于svn 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2016-03-16-memcache/">Memcache整理</a>
  </h1>
  <time datetime="2016-03-16T00:00:00Z" class="post-date">Wed, Mar 16, 2016</time>
  memcached是一个免费开源的，高性能的，具有分布式对象的缓存系统，它可以用来保存一些经常存取的对象或数据，保存的数据像一张巨大的HASH表，该表以Key-value对的方式存在内存中。
Memcached流程： 检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作。 如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）。 每次更新数据库的同时更新memcached中的数据，保证一致性。 当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。 Memcached特征： 协议简单 它是基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作
基于libevent事件处理 Libevent是一套利用C开发的程序库，它将BSD系统的kqueue,Linux系统的epoll等事件处理功能封装成一个接口，与传统的select相比，提高了性能。
内置的内存管理方式 所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过LRU算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务，所有数据会丢失。
分布式 各个memcached服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于memcache客户端。
Memcached的缓存策略： memcached的缓存策略是LRU（最近最少使用）加上到期失效策略。当你在memcached内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当memcached服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在LRU中，memcached使用的是一种Lazy Expiration策略，自己不会监控存入的key/vlue对是否过期，而是在获取key值时查看记录的时间戳，检查key/value对空间是否过期，这样可减轻服务器的负载。
Memcached的分布式算法： 当向memcached集群存入/取key/value时，memcached客户端程序根据一定的算法计算存入哪台服务器，然后再把key/value值存到此服务器中。 选择服务器算法有两种，一种是根据余数来计算分布，另一种是根据散列算法来计算分布。
余数算法： 先求得键的整数散列值，再除以服务器台数，根据余数确定存取服务器，这种方法计算简单，高效，但在memcached服务器增加或减少时，几乎所有的缓存都会失效。
散列算法： 先算出memcached服务器的散列值，并将其分布到0到2的32次方的圆上，然后用同样的方法算出存储数据的键的散列值并映射至圆上，最后从数据映射到的位置开始顺时针查找，将数据保存到查找到的第一个服务器上，如果超过2的32次方，依然找不到服务器，就将数据保存到第一台memcached服务器上。如果添加了一台memcached服务器，只在圆上增加服务器的逆时针方向的第一台服务器上的键会受到影响。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2016-03-04-php-encrypt-method/">几种常见的PHP加密算法</a>
  </h1>
  <time datetime="2016-03-04T00:00:00Z" class="post-date">Fri, Mar 4, 2016</time>
  ##Discuz authcode
&lt;?php /** * $string 明文或密文 * $operation 加密ENCODE或解密DECODE * $key 密钥 * $expiry 密钥有效期 */ function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) { // 动态密匙长度，相同的明文会生成不同密文就是依靠动态密匙 // 加入随机密钥，可以令密文无任何规律，即便是原文和密钥完全相同，加密结果也会每次不同，增大破解难度。 // 取值越大，密文变动规律越大，密文变化 = 16 的 $ckey_length 次方 // 当此值为 0 时，则不产生随机密钥 $ckey_length = 4; // 密匙 // $GLOBALS['discuz_auth_key'] 这里可以根据自己的需要修改 $key = md5($key ? $key : $GLOBALS['discuz_auth_key']); // 密匙a会参与加解密 $keya = md5(substr($key, 0, 16)); // 密匙b会用来做数据完整性验证 $keyb = md5(substr($key, 16, 16)); // 密匙c用于变化生成的密文 $keyc = $ckey_length ?
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2016-03-04-php-encrypt-method/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E8%8D%89%E7%A8%BF/2016-03-02-dangerously-set-innerhtml/">React学习 之 Dangerously Set innerHTML</a>
  </h1>
  <time datetime="2016-03-02T00:00:00Z" class="post-date">Wed, Mar 2, 2016</time>
  在学习React的过程中看到 dangerouslySetInnerHTML 这样奇怪的prop命名。
React特意设计这样的，以此提醒开发者，它的prop值应该是净化后的安全数据。
官网给出的原因是：
不合时宜的使用 innerHTML 可能会导致 cross-site scripting (XSS) 攻击。 净化用户的输入来显示的时候，经常会出现错误，不合适的净化也是导致网页攻击 的原因之一。
在彻底的理解安全问题后果并正确地净化数据之后，生成只包含唯一 key __html 的对象，并且对象的值是净化后的数据。
使用dangerouslySetInnerHTML：
function createMarkup() { return {__html: 'First &amp;middot; Second'}; }; &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt; 这么做的意义在于，当你不是有意地使用 &lt;div dangerouslySetInnerHTML={getUsername()} /&gt;时候，它并不会被渲染，因为 getUsername() 返回的格式是 字符串 而不是一个 {__html: ''} 对象。
{__html:...} 背后的目的是表明它会被当成 &quot;type/taint&quot; 类型处理。 这种包裹对象，可以通过方法调用返回净化后的数据，随后这种标记过的数据可以被传递给 dangerouslySetInnerHTML。 基于这种原因，我们不推荐写这种形式的代码：&lt;div dangerouslySetInnerHTML={{__html: getMarkup()}} /&gt;.
这个功能主要被用来与 DOM 字符串操作类库一起使用，所以提供的 HTML 必须要格式清晰（例如：传递 XML 校验 ）
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/javascript/2016-03-01-useragent-is-weixin-browser/">微信内置浏览器UserAgent的判断</a>
  </h1>
  <time datetime="2016-03-01T00:00:00Z" class="post-date">Tue, Mar 1, 2016</time>
  通过微信分享的URL链接都将通过微信内置的浏览器打开，那么如何区别判断是否是微信内置浏览器呢，很简单。
微信Android UA
mozilla/5.0 (linux; u; android 4.1.2; zh-cn; mi-one plus build/jzo54k) applewebkit/534.30 (khtml, like gecko) version/4.0 mobile safari/534.30 micromessenger/5.0.1.352 微信iPhone UA
mozilla/5.0 (iphone; cpu iphone os 5_1_1 like mac os x) applewebkit/534.46 (khtml, like gecko) mobile/9b206 micromessenger/5.0 微信的 User Agent 都有micromessenger字符串标示，通过判断是否含有这个字符串就OK了。
JS判断是否是微信内置的浏览器
function isWeixinBrowser(){ var ua = navigator.userAgent.toLowerCase(); return (/micromessenger/.test(ua)) ? true : false ; } 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E8%8D%89%E7%A8%BF/2016-02-29-mac-composer-install-problem/">Mac下安装composer遇到的问题</a>
  </h1>
  <time datetime="2016-02-29T00:00:00Z" class="post-date">Mon, Feb 29, 2016</time>
  ##安装composer
cd /usr/local/bin curl -sS https://getcomposer.org/installer | php 执行发现失败了，提示如下：
Some settings on your machine may cause stability issues with Composer. If you encounter issues, try to change the following: The OpenSSL library (0.9.8zc) used by PHP does not support TLSv1.2 or TLSv1.1. If possible you should upgrade OpenSSL to version 1.0.1 or above. Downloading... Could not create file /usr/local/bin/composer.phar: fopen(/usr/local/bin/composer.phar): failed to open stream: Permission denied Download failed: fopen(/usr/local/bin/composer.phar): failed to open stream: Permission denied fwrite() expects parameter 1 to be resource, boolean given 原来是Composer 依赖于 PHP，
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-12-29-shell-check-server/">自动检测程序正常运行，遇故障则重启服务</a>
  </h1>
  <time datetime="2015-12-29T00:00:00Z" class="post-date">Tue, Dec 29, 2015</time>
  在某些情况下，如系统负载过大server无法申请到内存而挂掉、server底层发生段错误、server占用内存过大被内核Kill，或者被某些程序误杀。那server将无法提供服务，导致业务中断，公司收入出现损失。
有一个非常有效并且常用的方案是crontab重启监控。
原理是每1分钟执行一次shell脚本，检测server的进程是否存活，如果存在则跳过。如果发现主进程已经挂掉，则执行restart逻辑，先kill掉所有残留的子进程，然后重新启动Server。
在系统的crontab中加入：
* * * * * /data/script/check_server.sh /data/script/check_server.sh：
#!/usr/bin/bash cmd=&quot;/application/php/bin/php /data/www/filter/http_server.php&quot; count=`ps aux |grep &quot;$cmd&quot; | grep -v &quot;grep&quot; | wc -l` echo $count if [ $count -lt 1 ]; then ps aux |grep &quot;$cmd&quot; | grep -v &quot;grep&quot;| awk '{print $2}'|xargs kill -9 sleep 2 $cmd echo &quot;restart &quot;$(date +%Y-%m-%d_%H:%M:%S) &gt;/data/log/restart.log fi 原文作者：松鼠先生
原文地址：无人值守，检测程序正常运行，遇故障则重启服务
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-25-redis&#43;mysql&#43;php-high-concurrence/">【高并发简单解决方案】redis队列缓存 &#43; mysql 批量入库 &#43; php离线整合</a>
  </h1>
  <time datetime="2015-12-25T00:00:00Z" class="post-date">Fri, Dec 25, 2015</time>
  需求背景：有个调用统计日志存储和统计需求，要求存储到mysql中；存储数据高峰能达到日均千万，瓶颈在于直接入库并发太高，可能会把mysql干垮。
问题分析
思考：应用网站架构的衍化过程中，应用最新的框架和工具技术固然是最优选择；但是，如果能在现有的框架的基础上提出简单可依赖的解决方案，未尝不是一种提升自我的尝试。
解决：
问题一：要求日志最好入库；但是，直接入库mysql确实扛不住，批量入库没有问题，done。【批量入库和直接入库性能差异参考文章】 问题二：批量入库就需要有高并发的消息队列，决定采用redis list 仿真实现，而且方便回滚。 问题三：日志量毕竟大，保存最近30条足矣，决定用php写个离线统计和清理脚本。 done，下面是小拽的简单实现过程
##一：设计数据库表和存储
考虑到log系统对数据库的性能更多一些，稳定性和安全性没有那么高，存储引擎自然是只支持select insert 没有索引的archive。如果确实有update需求，也可以采用myISAM。 考虑到log是实时记录的所有数据，数量可能巨大，主键采用bigint，自增即可。 考虑到log系统以写为主，统计采用离线计算，字段均不要出现索引，因为一方面可能会影响插入数据效率，另外读时候会造成死锁，影响写数据。 ##二：redis存储数据形成消息队列
由于高并发，尽可能简单，直接，上代码。
&lt;?php /*************************************************************************** * * 获取到的调用日志，存入redis的队列中. * $Id$ * **************************************************************************/ /** * @file saveLog.php * @date 2015/11/06 20:47:13 * @author:cuihuan * @version $Revision$ * @brief * **/ // 获取info $interface_info = $_GET['info']; // 存入redis队列 $redis = new Redis(); $redis-&gt;connect('xx', 6379); $redis-&gt;auth(&quot;password&quot;); // 加上时间戳存入队列 $now_time = date(&quot;Y-m-d H:i:s&quot;); $redis-&gt;rPush(&quot;call_log&quot;, $interface_info . &quot;%&quot; . $now_time); $redis-&gt;close(); /* vim: set ts=4 sw=4 sts=4 tw=100 */ ?
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-25-redis&#43;mysql&#43;php-high-concurrence/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-25-php-timing-task/">PHP设置定时任务的实现方法</a>
  </h1>
  <time datetime="2015-12-25T00:00:00Z" class="post-date">Fri, Dec 25, 2015</time>
  定时运行任务对于一个网站来说，是一个比较重要的任务，比如定时发布文档，定时清理垃圾信息等，现在的网站大多数都是采用PHP动态语言开发的，而对于PHP的实现决定了它没有Java和.Net这种AppServer的概念，而http协议是一个无状态的协议，PHP只能被用户触发，被调用，调用后会自动退出内存，没有常驻内存。
如果非要PHP去设置定时任务， 可以有以下三个方法：
##1、用户触发定时
通过挂载到网页里面，判断当前的时间，然后运行PHP代码，缺点是每一次加载网页，都需要加载这个PHP页面，而对于人气不旺的网站，这样的延时可能会更加的严重，毕竟是用户的HTTP请求去触发这个PHP代码的运行，Discuz!论坛程序是判断在00:00之后，第一个用户访问请求去执行定时的PHP代码。
##2、常驻内存运行
PHP是可以常驻内存运行程序的，下面的这段代码，可以在当前文件夹下，生成一个test.txt，并每隔20秒，往里面写入一个时间戳，无论客户端是否关闭浏览器。
&lt;?php ignore_user_abort(true); set_time_limit(0); function write_txt(){ if(!file_exists(&quot;test.txt&quot;)){ $fp = fopen(&quot;test.txt&quot;,&quot;wb&quot;); fclose($fp); } $str = file_get_contents(’test.txt’); $str .= &quot;\r\n&quot;.date(&quot;H:i:s&quot;); $fp = fopen(&quot;test.txt&quot;,&quot;wb&quot;); fwrite($fp,$str); fclose($fp); } function do_cron(){ usleep(20000000); write_txt(); } while(1){ do_cron(); } ?&gt; ###关键的两个函数
ignore_user_abort(true)，这个函数的作用是，无论客户端是否关闭浏览器，下面的代码都将得到执行。
set_time_limit(0)，这个函数的作用是，取消PHP文件的执行时间，如果没有这个函数的话，默认PHP的执行时间是30秒，也就是说30秒后，这个文件就会从内存中删除。
另外usleep函数是在PHP5.0后的版本中加入的函数，支持Windows操作系统，设置代码运行的时间，单位是毫秒(MS)。
###如何停止定时
但是当我执行脚本的时候，即使我关闭了浏览器，我根本就没法去停止这段程序了，所以你需要一个执行脚本的开关，你可以用外部文件引入的方法来实现，在while循环的时候，include开关变量即可。那么就可以这样实现：
建立外部引入变量文件 switch.php 内容如下：
&lt;?php return 1;//1执行脚本 0退出执行脚本 ?&gt; 这个脚本只是测试可行，具体效率应该不高，对于lamp，你完全可以使用crontab 来实现。
##3、服务器定时任务
服务器定时任务需要你是独立的服务器，或者是VPS，总之就是对系统的配置有足够的权限，虚拟空间就不要折腾这个方法了，因为你没有权限。
###Windows平台
在 Windows 平台下您可以将cli\php.exe 和 .php 文件的双击属性相关联，您也可以编写一个批处理文件来用 PHP 执行脚本。我们把写好的程序放在一个目录下如 E:\web\mail.php 。
然后写一个windows批处理文件内容如下：
@D:\php\cli\php.exe E:\web\mail.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-25-php-timing-task/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-25-ip-to-address/">根据ip查询所在地</a>
  </h1>
  <time datetime="2015-12-25T00:00:00Z" class="post-date">Fri, Dec 25, 2015</time>
  ##获取IP地址
&lt;?php function get_client_ip(){ if (isset($_SERVER)) { if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $realip = $_SERVER['HTTP_X_FORWARDED_FOR']; } elseif (isset($_SERVER['HTTP_CLIENT_IP'])) { $realip = $_SERVER['HTTP_CLIENT_IP']; } else { $realip = $_SERVER['REMOTE_ADDR']; } } else { if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;)) { $realip = getenv( &quot;HTTP_X_FORWARDED_FOR&quot;); } elseif (getenv(&quot;HTTP_CLIENT_IP&quot;)) { $realip = getenv(&quot;HTTP_CLIENT_IP&quot;); } else { $realip = getenv(&quot;REMOTE_ADDR&quot;); } } return $realip; } echo $ip = get_client_ip(); ?&gt; ##根据ip查询所在地
###新浪接口
&lt;?php $res0 = file_get_contents(&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=$ip&quot;); $res0 = json_decode($res0,true); print_r($res0); echo &quot;&lt;br/&gt;&quot;; ?
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-25-ip-to-address/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-23-preg-start/">正则表达式基础语法</a>
  </h1>
  <time datetime="2015-12-23T00:00:00Z" class="post-date">Wed, Dec 23, 2015</time>
  ##正则表达式是什么？
正则表达式只是一个字符串。没有长度限制，但是，这样的正则表达式长度往往较短。如下所示是一些正则表达式的例子：
I had a \S+ day today [A-Za-z0-9-_]{3,16} \d\d\d\d-\d\d-\d\d v(\d+)(.\d+)* TotalMessages=&quot;(.*?)&quot; &lt;[^&lt;&gt;]&gt; 这些字符串实际上都是微型计算机程序。正则表达式的语法，实际上是一种轻量级、简洁、适用于特定领域的编程语言。记住这一点，那么你就很容易理解下面的事情：
每一个正则表达式，都可以分解为一个指令序列，比如先找到这样的字符，再找到那样的字符，再从中找到一个字符。。。 每一个正则表达式都有输入（文本）和输出（匹配规则的输出，有时是修改后的文本） 正则表达式有可能出现语法错误——不是所有的字符串都是正则表达式 正则表达式语法很有个性，也可以说很恐怖 有时可以通过编译，使得正则表达式执行更快 正则表达式在文本编辑器中广泛使用，例如：
检查文本中是否含有指定的特征词 找出文中匹配特征词的位置 从文本中提取信息，比如：字符串的子串 修改文本 与文本编辑器相似，几乎所有的高级编程语言都支持正则表达式。在这样的语境下，文本也就是一个字符串，可以执行的操作都是类似的。一些编程语言（比如Perl，JavaScript）会检查正则表达式的语法。
特别提示：正则表达式与文件通配语法无关，比如 *.xml
##正则表达式的基础语法
###字符
普通字符只能匹配它们本身。但有一些被称为元字符的特殊字符，可以匹配一些特殊规则。如下所示的例子中已标出了元字符。
I had a \S+ day today [A-Za-z0-9\-_]{3,16} \d\d\d\d-\d\d-\d\d v(\d+)(\.\d+)* TotalMessages=&quot;(.*?)&quot; &lt;[^&lt;&gt;]&gt; 大部分的字符，包括所有的字母和数字字符，是普通字符。也就意味着，它们只能匹配它们自己，如下所示的正则表达式：
####cat
意味着，只能匹配一个字符串，以c开头，然后是字符a，紧跟着是字符t的字符串。
到目前为止，正则表达式的功能类似于
常规的Find功能 Java中的 String.indexOf() 函数 PHP中的 strpos()函数 等等 注意：不做特殊说明，正则表达式中是区分大小写的。但是，几乎所有正则表达式的实现，都会提供一个Flag用来控制是否区分大小写。
###点.
我们第一个要讲解的元字符是.。这个符号意味着可以匹配任意一个字符。如下所示的正则表达式：
####c.t
意味着匹配以c开头,之后是任意一个字符，紧跟着是字母t的字符串。
在一段文本中，这样的正则表达式可以用来找出cat, cot, czt这样的字符串，甚至可以找出c.t这样的组合，但是不能找到ct或者是coot这样的字符串。
使用反斜杠\可以忽略元字符，使得元字符的功能与普通字符一样。所以，正则表达式
####c\.t
表示找到字母c,然后是一个句号（.），紧跟着字母t
反斜杠本身也是一个元字符，这意味着反斜杠本身也可以通过相似的方法变回到普通字符的用途。因此，正则表达式
####c\\t
表示匹配以字符c开头,然后是一个反斜杠，紧跟着是字母t的字符串。
注意！在正则表达式的实现中，.是不能用于匹配换行符的。换行符的表示方法在不同实现中也不同。实际编程时，请参考相关文档。在本文中，我认为.是可以匹配任意字符的。实现环境通常会提供一个Flag标志位，来控制这一点。
###字符类
字符类是一组在方括号内的字符，表示可以匹配其中的任何一个字符。
正则表达式c[aeiou]t，表示可以匹配的字符串是以c开头，接着是aeiou中的任何一个字符，最后以t结尾。在文本的实际应用中，这样的正则表达式可以匹配：cat,cet,cit,cot,cut五种字符串。 正则表达式[0123456789]表示匹配任意一个整数。 正则表达式[a]表示匹配单字符a。 包含忽略字符的例子
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-23-preg-start/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-21-awesome-machine-learning/">Awesome Machine Learning</a>
  </h1>
  <time datetime="2015-12-21T00:00:00Z" class="post-date">Mon, Dec 21, 2015</time>
  Awesome Machine Learning A curated list of awesome machine learning frameworks, libraries and software (by language). Inspired by awesome-php.
If you want to contribute to this list (please do), send me a pull request or contact me @josephmisiti
For a list of free machine learning books available for download, go here.
C General-Purpose Machine Learning Recommender - A C library for product recommendations/suggestions using collaborative filtering (CF). Computer Vision CCV - C-based/Cached/Core Computer Vision Library, A Modern Computer Vision Library VLFeat - VLFeat is an open and portable library of computer vision algorithms, which has Matlab toolbox C++ Computer Vision OpenCV - OpenCV has C++, C, Python, Java and MATLAB interfaces and supports Windows, Linux, Android and Mac OS.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-21-awesome-machine-learning/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E7%94%9F%E6%B4%BB/2015-12-18-100-years-of-beauty/">100 Years of Beauty</a>
  </h1>
  <time datetime="2015-12-18T00:00:00Z" class="post-date">Fri, Dec 18, 2015</time>
  ###俄罗斯篇
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/javascript/2015-12-18-javascript-array-function/">Javascript各种数组方法</a>
  </h1>
  <time datetime="2015-12-18T00:00:00Z" class="post-date">Fri, Dec 18, 2015</time>
  ##数组的基本方法如下
####1. concat()
该方法用于连接2个或者多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
语法：arrayObject.concat(array1,array2,....arrayx);
连接多个数组，使用逗号隔开；
比如如下代码演示：
var arr1 = [1,2,3], arr2 = [4,5,6], arr3 = [7,8,9,1,2,3]; console.log(arr1.concat(arr2,arr3)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3] console.log(arr1); // [1,2,3] console.log(arr2); // [4,5,6] console.log(arr3); // [7,8,9,1,2,3] ####2. join()
该方法是把数组中的所有元素放入一个字符串中，元素通过指定的分隔符进行分割的。
语法如下：arrayObject.join(separator);
separator: 指定分隔符对数组中的元素进行分割，如果省略该参数，则会使用逗号作为分隔符。如下代码演示：
var arrs = []; arrs[0] = &quot;aa&quot;; arrs[1] = &quot;bb&quot;; arrs[2] = &quot;cc&quot;; console.log(arrs.join()); // aa,bb,cc console.log(arrs.join(&quot;/&quot;)); // aa/bb/cc console.log(arrs.join(&quot;-&quot;)); // aa-bb-cc ####3.pop()
该方法删除数组的最后一个元素，把数组的长度减1，并且返回它被删除元素的值，如果数组变为空，则该方法不改变数组，返回undefine值。如下代码演示：
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/javascript/2015-12-18-javascript-array-function/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/mysql/2015-12-17-mysql-update-varies-value/">mysql批量更新多条记录的不同值</a>
  </h1>
  <time datetime="2015-12-17T00:00:00Z" class="post-date">Thu, Dec 17, 2015</time>
  如果更新多条数据为不同的值，可能很多人会这样写：
foreach ($display_order as $id =&gt; $ordinal) { $sql = &quot;UPDATE categories SET display_order = $ordinal WHERE id = $id&quot;; mysql_query($sql); } 即是循环一条一条的更新记录。一条记录update一次，这样性能很差，也很容易造成阻塞。
那么能不能一条sql语句实现批量更新呢？
mysql并没有提供直接的方法来实现批量更新，但是可以用case when来实现。
UPDATE mytable SET myfield = CASE id WHEN 1 THEN 'value' WHEN 2 THEN 'value' WHEN 3 THEN 'value' END WHERE id IN (1,2,3) 这里的where部分不影响代码的执行，但是会提高sql执行的效率。确保sql语句仅执行需要修改的行数，这里只有3条数据进行更新，而where子句确保只有3行数据执行。
如果更新多个值的话，只需要稍加修改：
UPDATE categories SET display_order = CASE id WHEN 1 THEN 3 WHEN 2 THEN 4 WHEN 3 THEN 5 END, title = CASE id WHEN 1 THEN 'New Title 1' WHEN 2 THEN 'New Title 2' WHEN 3 THEN 'New Title 3' END WHERE id IN (1,2,3) 在业务中运用，需要结合服务端语言，这里以php为例，构造这条mysql语句：
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/mysql/2015-12-17-mysql-update-varies-value/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-17-php-files-directory/">php获取文件夹下所有文件，包含子文件夹</a>
  </h1>
  <time datetime="2015-12-17T00:00:00Z" class="post-date">Thu, Dec 17, 2015</time>
  /** * 获取文件夹下所有文件 * @param $directory 需要获取的文件夹 * @param bool $recursive 是否递归获取子文件夹 * @return array */ function directoryToArray($directory, $recursive = false) { $array_items = array(); if(!is_dir($directory)) return &quot;$directory folder does not exist&quot;; if ($handle = opendir($directory)) { while (false !== ($file = readdir($handle))) { if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) { if (is_dir($directory. &quot;/&quot; . $file)) { if($recursive) { $array_items = array_merge($array_items, directoryToArray($directory. &quot;/&quot; . $file, $recursive)); } $file = $directory .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-17-php-files-directory/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-16-php-run-time/">PHP调试执行时间</a>
  </h1>
  <time datetime="2015-12-16T00:00:00Z" class="post-date">Wed, Dec 16, 2015</time>
  ##获取一行或一段代码的执行时间
通常使用microtime函数获取代码前后的微秒时间数再比较两个值的时间差，但这种方法很有局限制，不能大范围的应用，而且每次都需要书写很多代码，适合于简单的调试。具体请查看PHP手册详细说明。代码如下：
&lt;?php function microtime_float(){ list($usec, $sec) = explode(&quot; &quot;, microtime()); return ((float)$usec + (float)$sec); } $time_start = microtime_float(); usleep(100); $time_end = microtime_float(); $time = $time_end - $time_start; echo &quot;Did nothing in $time seconds\n&quot;; ?&gt; ###microtime (PHP 3, PHP 4, PHP 5)
microtime &ndash; 返回当前 Unix 时间戳和微秒数 说明 mixed microtime ( [bool get_as_float] )
microtime() 当前 Unix 时间戳以及微秒数。本函数仅在支持 gettimeofday() 系统调用的操作系统下可用。 如果调用时不带可选参数，本函数以 &ldquo;msec sec&rdquo; 的格式返回一个字符串，其中 sec 是自 Unix 纪元（0:00:00 January 1, 1970 GMT）起到现在的秒数，msec 是微秒部分。字符串的两部分都是以秒为单位返回的。
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-16-php-run-time/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-06-win10-pid4-system/">win10下80端口被PID为4的System占用问题</a>
  </h1>
  <time datetime="2015-12-16T00:00:00Z" class="post-date">Wed, Dec 16, 2015</time>
  ###Windows10下80端口被PID为4的System占用导致Apache无法启动的分析与解决方案
用命令 netstat -ano|findstr 80 来查看一下到底是哪个程序占用了80端口，如图所示端口查找的结果：
system进程占用80端口
![system进程占用80端口][p1] [p1]: /images/1.png &ldquo;system进程占用80端口&rdquo;
![system进程占用80端口][p2] [p2]: /images/2.png &ldquo;system进程占用80端口&rdquo;
![当前的http服务状态][p3] [p3]: /images/3.png &ldquo;当前的http服务状态&rdquo;
![PID1600进程][p4] [p4]: /images/4.png &ldquo;PID1600进程&rdquo;
![PID1600进程所在的服务][p5] [p5]: /images/5.png &ldquo;PID1600进程所在的服务&rdquo;
###解决方案
![解决方案][p6] [p6]: /images/6.png &ldquo;解决方案&rdquo;
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-15-shortcut-save-url/">收藏到桌面的快捷方式</a>
  </h1>
  <time datetime="2015-12-15T00:00:00Z" class="post-date">Tue, Dec 15, 2015</time>
  收藏到桌面的快捷方式，使用链接：_path_/shortcut.php?url=_url_&amp;filename=_filename_
//shortcut.php &lt;?php $url = $_GET['url']; $filename = $_GET['filename']; $ShortCut = &quot; [DEFAULT] BASEURL=&quot;.$url.&quot; [InternetShortcut] URL=&quot;.$url.&quot; Modified=B07A55D9386FCA01CA IconFile=_url_/favicon.ico IconIndex=1 &quot;; Header(&quot;Content-type: application/octet-stream&quot;); header(&quot;Content-Disposition: attachment; filename=&quot;.$filename.&quot;.url;&quot;); echo $ShortCut; 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2015-12-10-ui-elements/">各种常见的UI元素</a>
  </h1>
  <time datetime="2015-12-10T00:00:00Z" class="post-date">Thu, Dec 10, 2015</time>
  ##按钮
####色块按钮
&lt;a class=&quot;btn&quot;&gt;按钮&lt;/a&gt; &lt;style&gt; .btn {background-color: #c2c2c2;color: #fff;border-radius: 3px; border: 1px solid transparent; border-radius: 4px; cursor: pointer; display: inline-block; font-size: 14px; font-weight: 400; line-height: 1.5; margin-bottom: 0; padding: 6px 12px; text-align: center; vertical-align: middle; white-space: nowrap; text-decoration: none; } .btn:active,.btn:hover {background-color:#bababa; border-color:#bababa;} &lt;/style&gt; ####线框按钮
&lt;a class=&quot;btn&quot;&gt;按钮&lt;/a&gt; &lt;style&gt; .btn {color: #c2c2c2;border-radius: 3px; border: 1px solid #c2c2c2; border-radius: 4px; cursor: pointer; display: inline-block; font-size: 14px; font-weight: 400; line-height: 1.5; margin-bottom: 0; padding: 6px 12px; text-align: center; vertical-align: middle; white-space: nowrap; text-decoration: none; } .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2015-12-10-ui-elements/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2014-12-08-jquery-plugin/">jQuery插件开发笔记</a>
  </h1>
  <time datetime="2015-12-08T00:00:00Z" class="post-date">Tue, Dec 8, 2015</time>
  jQuery插件的开发包括两种：
一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数。 另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。 类级别的插件开发 类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：
添加一个新的全局函数 添加一个全局函数，我们只需如下定义：
jQuery.foo = function() { alert('This is a test. This is only a test.'); }; 增加多个全局函数 添加多个全局函数，可采用如下定义：
jQuery.foo = function() { alert('This is a test. This is only a test.'); }; jQuery.bar = function(param) { alert('This function takes a parameter, which is &quot;' + param + '&quot;.'); }; 调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar('bar'); 使用jQuery.extend(object);　jQuery.extend({ foo: function() { alert('This is a test. This is only a test.'); }, bar: function(param) { alert('This function takes a parameter, which is &quot;' + param +'&quot;.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2014-12-08-jquery-plugin/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-06-shell-method-terminal/">执行系统命令的函数</a>
  </h1>
  <time datetime="2015-12-06T00:00:00Z" class="post-date">Sun, Dec 6, 2015</time>
  system, exec, passthru, shell_exec 这4个函数可用于执行系统命令。每个的行为都有细微差别。问题在于, 当在共享主机中, 某些函数可能被选择性的禁用. 大多数新手趋于每次首先检查哪个函数可用, 然而再使用它。更好的方案是封成函数一个可跨平台的函数。
/** Method to execute a command in the terminal Uses : 1. system 2. passthru 3. exec 4. shell_exec */ function terminal($command){ //system if(function_exists('system')){ ob_start(); system($command , $return_var); $output = ob_get_contents(); ob_end_clean(); } //passthru else if(function_exists('passthru')){ ob_start(); passthru($command , $return_var); $output = ob_get_contents(); ob_end_clean(); } //exec else if(function_exists('exec')){ exec($command , $output , $return_var); $output = implode(&quot;\n&quot; , $output); } //shell_exec else if(function_exists('shell_exec')){ $output = shell_exec($command) ; } else{ $output = 'Command execution not possible on this system'; $return_var = 1; } return array('output' =&gt; $output , 'status' =&gt; $return_var); } terminal('ls'); 上面的函数將运行shell命令, 只要有一个系统函数可用, 这保持了代码的一致性。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-03-jekyll-template-grammer/">Jekyll模板变量&amp;语法</a>
  </h1>
  <time datetime="2015-12-03T00:00:00Z" class="post-date">Thu, Dec 3, 2015</time>
  Jekyll会遍历你的站点，来寻找需要处理的文件。
任何具有 YAML 前置数据的文件都将会被处理，每一个这样的文件，Jekyll都会通过Liquid模板系统使用许多可用的页面变量。
下面是一个可用变量的列表。
###Jekyll 目录及一些说明
文件/目录 说明 Jekyll 标准目录树 _config.yml Jekyll的配置文件 _includes include 文件所在的文件夹 _layouts 模版文件夹 _posts 自己要发布的内容 _sites 预览时产生的文件都放在该文件夹中 _includes文件夹中所放的文件是最终要放到模版中的一些代码片段。 _layouts中放的一些模版，模版是用包含page或post内容的。Jekyll的模版使用HTML语法来写，并包含YAML Front Matter。所有的模版都可用Liquid来与网站进行交互。所的的模版都可以使用全局变量site和page，site变量包含该网站所有可以接触得到的内容和元数据(meta-data)，page变量包含的是当前渲染的page或post的所有可以接触得到的数据。 _post文件夹中放的是自己要发布的post文章。post文件的命名规则为YEAR-MONTH-DATE-title.MARKUP，使用rake post会自动将post文件命名合适。而对于page，所有放在根目录下或不以下划线开头的文件夹中有格式的文件都会被Jekyll处理成page。这里说的有格式是指文件含有YAML Front Matter。所有的post和page都要用markdown或者texile或者HTML语法来写，并可以包含Liquid模版的语法。还要有 YAML Front Matter (Jekyll只处理具有YAML Front Matter的文件)。YAML Front Matter必须放在文件的开头，一对&mdash;之间，用户可在这一对&mdash;间设置预先定义的变量或用户自己的数据。 ###Jekyll模板全局变量
变量 描述 site.time 当前的时间(当你运行Jekyll时的时间) site.posts 一个按时间逆序的文章列表。 site.related_posts 如果当前被处理的页面是一个文章文件，那这个变量是一个包含了最多10篇相关文章的列表。默认来说，这些相关文章是低质量但计算快的。为了得到高质量但计算慢的结果，运行Jekyll命令时可以加上&ndash;lsi选项。(潜在语意索引) site.categories.CATEGORY 所有在CATEGORY分类中的文章列表 site.tags.TAG 所有拥有TAG标签的文章的列表 site.[CONFIGURATION_DATA] 截止0.5.2版本，所有在_config.yml中的数据都能够通过site变量调用。举例来说，如果你有一个这样的选项在你的配置文件中:url: http://higrid.net，那在文章和页面文件中可以这样调用{ { site.url } }。Jekyll并不会自动解析修改过的_config.yml文件，你想要启用新的设置选项，你需要重启Jekyll ###Jekyll模板Page变量
变量 描述 page.content 页面中未渲染的内容 page.title 文章的标题 page.url 除去域名以外的URL，例子:/2013/12/14/higrid-net.html page.date 指定每一篇文章的时间，这个选项能够覆盖一篇文章中前置数据设置的时间，它的格式是这样的:YYYY-MM-DD HH:MM:SS page.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-12-03-jekyll-template-grammer/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-03-php-zip-so/">测试phpexcel后报错Class &#39;ZipArchive&#39; not found解决方法</a>
  </h1>
  <time datetime="2015-12-03T00:00:00Z" class="post-date">Thu, Dec 3, 2015</time>
  今天想做一个从数据库导出订单生成excel,在本地运行测试就报错Class 'ZipArchive' not found.
解决方法:
##在window系统下:
php.ini文件中，将extension=php_zip.dll前面的分号“;”去除,将 zlib.output_compression = Off 改为 zlib.output_compression = On,重启apache
##在linux系统下:
要重新下载编译php_zip.dll
cd /usr/src wget http://pecl.php.net/get/zip tar -zxvf zip cd zip-1.x.x phpize ./configure make sudo make install 安装后记录屏幕下的zip.so的位置,例如/usr/local/lib/php/extensions/zip.so
在php.ini里面,增加extension = /usr/local/lib/php/extensions/zip.so，然后，将 zlib.output_compression = Off 改为 zlib.output_compression = On
最后重启apache: service httpd restart
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2015-12-02-jquery-plugin-template/">jQuery插件模板</a>
  </h1>
  <time datetime="2015-12-02T00:00:00Z" class="post-date">Wed, Dec 2, 2015</time>
  此 jQuery 插件模板出自：jQuery Plugin Boilerplate, revisited
// jQuery Plugin Boilerplate // A boilerplate for jumpstarting jQuery plugins development // version 1.1, May 14th, 2011 // by Stefan Gabos // remember to change every instance of &quot;pluginName&quot; to the name of your plugin! (function($) { // here we go! $.pluginName = function(element, options) { // plugin's default options // this is private property and is accessible only from inside the plugin var defaults = { foo: 'bar', // if your plugin is event-driven, you may provide callback capabilities // for its events.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2015-12-02-jquery-plugin-template/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-02-memcache/">Memcache基本教程</a>
  </h1>
  <time datetime="2015-12-02T00:00:00Z" class="post-date">Wed, Dec 2, 2015</time>
  Memcache是danga.com的一个项目，最早是为 LiveJournal 服务的，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力。 它可以应对任意多个连接，使用非阻塞的网络IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个HashTable，Memcached自管理这些HashTable。 Memcache官方网站：http://www.danga.com/memcached，更多详细的信息可以来这里了解 :)
###为什么会有Memcache和memcached两种名称？ 其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名，知道我的意思了把~~~~。一个是项目名称，一个是主程序文件名，在网上看到了很多人不明白，于是混用了。
##Memcache的安装 分为两个过程：memcache服务器端的安装和memcached客户端的安装。 所谓服务器端的安装就是在服务器（一般都是linux系统）上安装Memcache实现数据的存储 所谓客户端的安装就是指php（或者其他程序，Memcache还有其他不错的api接口提供）去使用服务器端的Memcache提供的函数，需要php添加扩展。
###具体的配置大家可以参考： Linux下的Memcache安装：http://www.ccvita.com/257.html Windows下的Memcache安装：http://www.ccvita.com/258.html Memcache基础教程：http://www.ccvita.com/259.html Discuz!的Memcache缓存实现：http://www.ccvita.com/261.html Memcache协议中文版：http://www.ccvita.com/306.html Memcache分布式部署方案：http://www.ccvita.com/395.html
##PHP的Memcache
&lt; ?php //连接 $mem = new Memcache; $mem-&gt;connect(&quot;192.168.0.200&quot;, 12000); //保存数据 $mem-&gt;set('key1', 'This is first value', 0, 60); $val = $mem-&gt;get('key1'); echo &quot;Get key1 value: &quot; . $val .&quot;&lt;br /&gt;&quot;; //替换数据 $mem-&gt;replace('key1', 'This is replace value', 0, 60); $val = $mem-&gt;get('key1'); echo &quot;Get key1 value: &quot; . $val . &quot;&lt;br /&gt;&quot;; //保存数组 $arr = array('aaa', 'bbb', 'ccc', 'ddd'); $mem-&gt;set('key2', $arr, 0, 60); $val2 = $mem-&gt;get('key2'); echo &quot;Get key2 value: &quot;; print_r($val2); echo &quot;&lt;br /&gt;&quot;; //删除数据 $mem-&gt;delete('key1'); $val = $mem-&gt;get('key1'); echo &quot;Get key1 value: &quot; .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-02-memcache/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2014-12-01-one-line-browser-notepad/">一行代码，浏览器变临时编辑器</a>
  </h1>
  <time datetime="2015-12-01T00:00:00Z" class="post-date">Tue, Dec 1, 2015</time>
  这是 Jose 在CoderWall 分享的一个小技巧：在浏览器地址栏中输入下面这行代码，回车即可把浏览器变临时编辑器。
data:text/html, &lt;html contenteditable&gt; 代码高亮编辑器
data:text/html, &lt;style type=&quot;text/css&quot;&gt;#e{position:absolute;top:0;right:0;bottom:0;left:0;}&lt;/style&gt;&lt;div id=&quot;e&quot;&gt;&lt;/div&gt;&lt;script src=&quot;http://d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;script&gt;var e=ace.edit(&quot;e&quot;);e.setTheme(&quot;ace/theme/monokai&quot;);e.getSession().setMode(&quot;ace/mode/ruby&quot;);&lt;/script&gt; 改造成支持其他语言语法高亮的，可把 ace/mode/ruby 替换为： Python -&gt; ace/mode/python C/C++ -&gt; ace/mode/c_cpp Javscript -&gt; ace/mode/javascript Java -&gt; ace/mode/java Scala -&gt; ace/mode/scala Markdown -&gt; ace/mode/markdown CoffeeScript -&gt; ace/mode/coffee 其他…… jakeonrails 语法高亮风格用的是 monokai。 如果需要换成其他风格，，可把 ace/theme/monokai 替换为： Eclipse -&gt; ace/theme/eclipse TextMate -&gt; ace/theme/textmate 其他…… 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-01-php-zend_search_lucene-cn-search/">使用PHP&#43;Zend_Search_Lucene做全站中文搜索引擎</a>
  </h1>
  <time datetime="2015-12-01T00:00:00Z" class="post-date">Tue, Dec 1, 2015</time>
  1.概述 Zend_Search_Lucene是一个完全基于PHP5的通用文本搜索引擎，它将索引存储在文件系统中，不需要数据库服务器。
2. 安装Zend_Lucene 可以从这里下载: http://www.zend.com/community/downloads
也可以参考这篇文章：http://nonfu.me/p/4650.html 的下载目录去下载Zend Framework导入。
找到Zend文件夹下的Search目录，所需要的文件都在里面了。
3.创建索引 下面是创建索引的示例:
&lt;?php require_once 'Zend/Search/Lucene.php'; $articlesData = array( 0=&gt;array('id'=&gt;1,'title'=&gt;'test','content'=&gt;'this is a test'), 1=&gt;array('id'=&gt;2,'title'=&gt;'test php','content'=&gt;'this is a php test'), 2=&gt;array('id'=&gt;3,'title'=&gt;'test yii','content'=&gt;'this is a yii test'), 3=&gt;array('id'=&gt;4,'title'=&gt;'test lucene','content'=&gt;'this is a lucene test'), 4=&gt;array('id'=&gt;5,'title'=&gt;'测试','content'=&gt;'这是一个简单的搜索测试'), 5=&gt;array('id'=&gt;6,'title'=&gt;'测一个小试','content'=&gt;'我们进行一个小测验吧'), 6=&gt;array('id'=&gt;6,'title'=&gt;'白色的马','content'=&gt;'白色的小马驹') ); $index = new Zend_Search_Lucene('/path/to/index',true); $doc = new Zend_Search_Lucene_Document(); foreach ($articlesData as $article) { $doc-&gt;addField(Zend_Search_Lucene_Field::keyword('id',$article['id'],'UTF-8')); $doc-&gt;addField(Zend_Search_Lucene_Field::Text('title',$article['title'],'UTF-8')); $doc-&gt;addField(Zend_Search_Lucene_Field::keyword('content',$article['content'],'UTF-8')); $index-&gt;addDocument($doc); $index-&gt;commit(); $index-&gt;optimize(); } echo '索引创建成功！'; 在实际案例中，索引数据应该来自数据库，在上面的示例中，我们的所有索引数据都可以用数据库查询的结果来替代。
4.搜索索引数据 创建索引之后我们就可以通过下面的代码来搜索了:
$index = new Zend_Search_Lucene('/path/to/index'); $keywords = &quot;test&quot;; //echo &quot;Index包含{$index-&gt;count()}条结果&lt;br&gt;&quot;; $query = Zend_Search_Lucene_Search_QueryParser::parse($keywords,'utf-8'); $hits = $index-&gt;find($query); foreach($hits as $hit){ echo $hit-&gt;id.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-12-01-php-zend_search_lucene-cn-search/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/mysql/2015-11-26-mysql-rand-n-row/">从Mysql某一表中随机读取n条数据的SQL查询语句</a>
  </h1>
  <time datetime="2015-11-26T00:00:00Z" class="post-date">Thu, Nov 26, 2015</time>
  若要在i ≤ R ≤ j这个范围得到一个随机整数R ，需要用到表达式 FLOOR(i + RAND() * (j – i + 1))。 例如， 若要在7 到 12 的范围（包括7和12）内得到一个随机整数, 可使用以下语句：
SELECT FLOOR(7 + (RAND() * 6)); 从 Mysql 表中随机读取数据不难，方法还挺多的，但是如果要考虑效率，得到一个快速的高效率的方法，那就不是一件简单的事情了（至少对我来说不简单）。
随机获得Mysql数据表的一条或多条记录有很多方法，下面我就以users（userId，userName，password……）表（有一百多万条记录）为例，对比讲解下几个方法效率问题：
select * from users order by rand() LIMIT 1 执行该sql语句，老半天没有反应，最后被迫手动停止执行，怎个伤人了得啊！后来我查了一下MYSQL手册，里面针对RAND()的提示大概意思就是，在 ORDER BY从句里面不能使用RAND()函数，因为这样会导致数据列被多次扫描，导致效率相当相当的低！效率不行，切忌使用！
SELECT * FROM users AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(userId) FROM `users`)-(SELECT MIN(userId) FROM users))+(SELECT MIN(userId) FROM users)) AS userId) AS t2 WHERE t1.userId &gt;= t2.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/mysql/2015-11-26-mysql-rand-n-row/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-11-19-data-hiding-in-image/">用图片隐藏信息的技术实现</a>
  </h1>
  <time datetime="2015-11-19T00:00:00Z" class="post-date">Thu, Nov 19, 2015</time>
  隐藏的过程很简单，用 Windows 内置的文件拷贝命令，即可完成。假设你的图片文件叫 A.jpg，需要隐藏的文件是B.txt（压缩文件叫 B.zip），那你只需要执行如下命令，就可以把两个文件合并成一个新文件。
copy /b A.JPG + B.txt C.jpg copy /b A.JPG + B.zip C.jpg 执行完如上命令，即可得到一个新的图片文件 C.JPG。这个图片文件的大小是前两者的总和。你可以用各种看图工具来打开 C.JPG，不会看到什么异常。 如果你覆盖的是文件，直接用记事本打开，在文件最后就可以看到里面的内容。 如果你覆盖的是压缩文件，提取的时候，可以用压缩工具打开图片，就可以直接看到压缩包里面的内容了。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E5%85%B6%E4%BB%96/2015-11-02-all-country-list/">全部国家列表</a>
  </h1>
  <time datetime="2015-11-02T00:00:00Z" class="post-date">Mon, Nov 2, 2015</time>
  联合国官方资料：
共有195个国家
亚洲 Asia -49个国家
蒙古 中国 北韩 南韩 日本 台湾 缅甸 泰国 寮国 越南 柬埔寨 马来西亚 新加坡 印尼 汶莱 东帝汶 菲律宾 巴基斯坦 印度 尼泊尔 不丹 孟加拉 斯里兰卡 马尔地夫 哈萨克 乌兹别克 土库曼 吉尔吉斯 塔吉克 阿富汗 亚塞拜然 乔治亚 亚美尼亚 伊朗 土耳其 叙利亚 伊拉克 黎巴嫩 以色列 巴勒斯坦 约旦 沙乌地阿拉伯 科威特 巴林 卡达 阿拉伯联合大公国 阿曼 叶门 塞浦路斯
欧洲 Europe -43个国家
芬兰 瑞典 挪威 丹麦 冰岛 俄罗斯 爱沙尼亚 拉脱维亚 立陶宛 白俄罗斯 乌克兰 摩尔多瓦 波兰 捷克 斯洛伐克 匈牙利 罗马尼亚 保加利亚 斯洛维尼亚 克罗埃西亚 波士尼亚 塞尔维亚 马其顿 阿尔巴尼亚 德国 瑞士 列支敦斯登 奥地利 荷兰 比利时 卢森堡 法国 安道尔 摩纳哥 英国 爱尔兰 希腊 义大利 圣马利诺 教廷(梵蒂冈) 西班牙 葡萄牙 马尔他
  
  <div class="read-more-link">
    <a href="/Blog/post/%E5%85%B6%E4%BB%96/2015-11-02-all-country-list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E5%85%B6%E4%BB%96/2015-11-02-all-api/">各种API</a>
  </h1>
  <time datetime="2015-11-02T00:00:00Z" class="post-date">Mon, Nov 2, 2015</time>
  天气API&mdash;&ndash;开源免费天气预报接口API以及全国所有地区代码！！（国家气象局提供） 。
国家气象局提供的天气预报接口
接口地址：
http://www.weather.com.cn/data/sk/101010100.html
http://www.weather.com.cn/data/cityinfo/101010100.html
http://m.weather.com.cn/data/101010100.html
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-29-curl-login/">curl模拟登陆</a>
  </h1>
  <time datetime="2015-10-29T00:00:00Z" class="post-date">Thu, Oct 29, 2015</time>
  用PHP开发模拟浏览器的应用,首选技术是CURL函数库。但是php官方提供的技术文档资料很少，相关的示例代码也很少。
最 近由于项目需要，开发了一系列免费邮箱的导出用户自己联系人的功能，包括国内外知名邮 箱，163，sina，sohu,yahoo,hotmail,gmail,qq mail等。还开发了一些方便用户嵌入代码到各大博客，个人门户的应用。比如嵌入flash代码到Qzone，网易的blog，百度的个人门户等。
当然，最原始的技术手段是采用fsockopen函数，然后深入去学习http协议，写出标准的http头信息，也是可以完成开发的。不过麻烦的地方就出在标准。如果对http协议标准认识不深，经常会因碰到少了一个空格或者少了一个换行符号而debug很久。
OK， 还是进入正题。工欲善其事，必先利其器。要模拟浏览器访问网站，首选要学会观察浏览器是如何发送http报文的，以及网站服务器返回给浏览器 是什么样的内容。我推荐安装一个国外人开发的httpwatch的软件，最好搞个破解的版本，否则有些功能是使用不了的。这个软件安装完成之后是嵌入在 IE里的，启动Record，在地址栏输入网址后回车，它就会将浏览器和服务器之间的所有通讯扫描出来，让你一览无遗。关于这个软件的使用在本文不做介 绍。
模拟浏览器登陆应用开发，最关键的地方是突破登陆验证。CURL技术不只支持http，还支持https。区别就在多了一层SSL加密传输。如果是要登陆 https网站，php记得要支持openssl。还是先拿一个例子来分析。
// 用户名 $login = ‘username’; //密码 $password = ‘password’; //163的用户登陆地址 $url = “https://reg.163.com/logins.jsp”; //post 要提交的数据 $fields = “verifycookie=1&amp;style=16&amp;product=mail163&amp;username=”.$login.”&amp;password=”.$password.”&amp;selType=jy&amp;remUser=&amp;secure=on&amp;%B5%C7%C2%BC%D3%CA%CF%E4=%B5%C7%C2%BC%D3%CA%CF%E4″; // 用来存放cookie的文件 $cookie_file = dirname(__FILE__).”/cookie.txt”; // 启动一个CURL会话 $ch = curl_init(); // 要访问的地址 curl_setopt($ch, CURLOPT_URL, $url); // 对认证证书来源的检查，0表示阻止对证书的合法性的检查。 curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); // 从证书中检查SSL加密算法是否存在 curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 1); //模拟用户使用的浏览器，在HTTP请求中包含一个”user-agent”头的字符串。 curl_setopt($ch, CURLOPT_USERAGENT, “Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)”); // 发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样。 curl_setopt($ch, CURLOPT_POST, 1); //要传送的所有数据，如果要传送一个文件，需要一个@开头的文件名 curl_setopt($ch, CURLOPT_POSTFIELDS, $fields); //连接关闭以后，存放cookie信息的文件名称 curl_setopt($ch, CURLOPT_COOKIEJAR, $cookie_file); // 包含cookie信息的文件名称，这个cookie文件可以是Netscape格式或者HTTP风格的header信息。 curl_setopt($ch, CURLOPT_COOKIEFILE, $cookie_file); // 设置curl允许执行的最长秒数 //curl_setopt($ch, CURLOPT_TIMEOUT, 6); // 获取的信息以文件流的形式返回，而不是直接输出。 curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); // 执行操作 $result = curl_exec($ch); if ($result == NULL) { echo “Error: “; echo curl_errno($ch) .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-29-curl-login/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-10-27-msvcr100u-dll/">如何解决msvcr100.dll丢失问题</a>
  </h1>
  <time datetime="2015-10-27T00:00:00Z" class="post-date">Tue, Oct 27, 2015</time>
  msvcr100.dll是Visual Studio 2010的一个动态链接库，如果某程序是用它开发出来的，那么该程序的运行就有可能需要此动态链接库，有些程序直接将其打包到了安装目录，并注册，就不会出现缺失的问题；但有些程序则默认系统中有此动态链接库，没有进行处理，那就会出现缺失的问题。
解决方法一：
下载MSVCR100.dll，然后放到系统中，注意存放的系统路径：
1、32位系统，dll放在：\Windows\System32
2、64位系统需要放两个dll文件，一个32位，一个64位（下面两个一定要看仔细，反的）：32位dll放在：\Windows\SysWOW64, 64位dll放在：\Windows\System32
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2015-10-21-jquery-little-method/">常用的jQuery小技巧</a>
  </h1>
  <time datetime="2015-10-21T00:00:00Z" class="post-date">Wed, Oct 21, 2015</time>
  1. 如何创建嵌套的过滤器
//允许你减少集合中的匹配元素的过滤器， //只剩下那些与给定的选择器匹配的部分。在这种情况下， //查询删除了任何没（:not）有（:has） //包含class为“selected”（.selected）的子节点。 .filter(&quot;:not(:has(.selected))&quot;) 2. 如何重用元素搜索
var allItems = $(&quot;div.item&quot;); var keepList = $(&quot;div#container1 div.item&quot;); //现在你可以继续使用这些jQuery对象来工作了。例如， //基于复选框裁剪“keep list”，复选框的名称 //符合 &lt;DIV&gt;class names:x $(formToLookAt + &quot; input:checked&quot;).each(function() { keepList = keepList.filter(&quot;.&quot; + $(this).attr(&quot;name&quot;)); }); &lt;/DIV&gt; 3. 任何使用has()来检查某个元素是否包含某个类或是元素
//jQuery 1.4.*包含了对这一has方法的支持。该方法找出 //某个元素是否包含了其他另一个元素类或是其他任何的 //你正在查找并要在其之上进行操作的东东。 $(&quot;input&quot;).has(&quot;.email&quot;).addClass(&quot;email_icon&quot;); 4. 如何使用jQuery来切换样式表 //找出你希望切换的媒体类型（media-type），然后把href设置成新的样式表。 5. 如何限制选择范围（基于优化目的）
//尽可能使用标签名来作为类名的前缀， //这样jQuery就不需要花费更多的时间来搜索 //你想要的元素。还要记住的一点是， //针对于你的页面上的元素的操作越具体化， //就越能降低执行和搜索的时间。 var in_stock = $('#shopping_cart_items input.is_in_stock'); &lt;ul id=&quot;shopping_cart_items&quot;&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-X&quot; name=&quot;item&quot; class=&quot;is_in_stock&quot; /&gt;Item X&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-Y&quot; name=&quot;item&quot; class=&quot;3-5_days&quot; /&gt;Item Y&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-Z&quot; name=&quot;item&quot; class=&quot;unknown&quot; /&gt;Item Z&lt;/li&gt; &lt;/ul&gt; 6.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2015-10-21-jquery-little-method/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-14-php-is-mobile/">PHP 判断设备是否是手机/平板的方法</a>
  </h1>
  <time datetime="2015-10-14T00:00:00Z" class="post-date">Wed, Oct 14, 2015</time>
  在做WEB开发的时候经常会需要用到对移动设备的页面匹配，当然可以直接把网站做成响应式的，但如果不想这么做的话，可以使用PHP对设备类型进行判断，然后显示相应的界面和内容。今天分享一种使用 PHP 判断设备是否是手机/平板的方法，方法来源于WordPress(wp-includes/vars.php:125)，适用于大部分类型的手机/平板判断：
在做WEB开发的时候经常会需要用到对移动设备的页面匹配，当然可以直接把网站做成响应式的，但如果不想这么做的话，可以使用PHP对设备类型进行判断，然后显示相应的界面和内容。今天分享一种使用 PHP 判断设备是否是手机/平板的方法，方法来源于WordPress(wp-includes/vars.php:125)，适用于大部分类型的手机/平板判断：
/** * Test if the current browser runs on a mobile device (smart phone, tablet, etc.) * * @staticvar bool $is_mobile * * @return bool */ function wp_is_mobile() { static $is_mobile = null; if ( isset( $is_mobile ) ) { return $is_mobile; } if ( empty($_SERVER['HTTP_USER_AGENT']) ) { $is_mobile = false; } elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Mobile') !== false // many mobile devices (all iPhone, iPad, etc.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-14-php-is-mobile/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-10-simple-factory-mode/">PHP设计模式之简单工厂模式</a>
  </h1>
  <time datetime="2015-10-10T00:00:00Z" class="post-date">Sat, Oct 10, 2015</time>
  简单工厂模式：
①抽象基类：类中定义抽象一些方法，用以在子类中实现 ②继承自抽象基类的子类：实现基类中的抽象方法 ③工厂类：用以实例化对象 使用情景：在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。
##采用封装方式
&lt;?php class Calc{ /** * 计算结果 * * @param int|float $num1 * @param int|float $num2 * @param string $operator * @return int|float */ public function calculate($num1,$num2,$operator){ try { $result=0; switch ($operator){ case '+': $result= $num1+$num2; break; case '-': $result= $num1-$num2; break; case '*': $result= $num1*$num2; break; case '/': if ($num2==0) { throw new Exception(&quot;除数不能为0&quot;); } $result= $num1/$num2; break; } return $result; }catch (Exception $e){ echo &quot;您输入有误:&quot;.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-10-simple-factory-mode/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-10-php-simple-methods/">简单实用的PHP函数</a>
  </h1>
  <time datetime="2015-10-10T00:00:00Z" class="post-date">Sat, Oct 10, 2015</time>
  ###对象到数组转换
function objToArr($obj){ if(!is_object($obj) &amp;&amp; !is_array($obj)) { return $obj; } $arr = array(); foreach($obj as $k =&gt; $v){ $arr[$k] = $this-&gt;objToArr($v); } return $arr; } ###json到php数组转换
function simple_json_parser($json){ $json = str_replace(&quot;{&quot;,&quot;&quot;,str_replace(&quot;}&quot;,&quot;&quot;, $json)); $jsonValue = explode(&quot;,&quot;, $json); $arr = array(); foreach($jsonValue as $v){ $jValue = explode(&quot;:&quot;, $v); $arr[str_replace('&quot;',&quot;&quot;, $jValue[0])] = (str_replace('&quot;', &quot;&quot;, $jValue[1])); } return $arr; } ###curl 实现 GET / POST
function oauth_http($method,$header,$url,$data){ $method = $method ? $method : 'get'; if( $method == 'get') { $ch = curl_init (); curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, TRUE ); curl_setopt ( $ch, CURLOPT_URL, $url ); $result = curl_exec ( $ch ); curl_close ( $ch ); return $result; } elseif ( $method == 'post' ) { $ch = curl_init(); curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, TRUE ); curl_setopt ( $ch, CURLOPT_POST, TRUE ); curl_setopt ( $ch, CURLOPT_POSTFIELDS, $data ); curl_setopt ( $ch, CURLOPT_URL, $url ); curl_setopt ( $ch, CURLOPT_SSL_VERIFYPEER, FALSE); $ret = curl_exec ( $ch ); curl_close ( $ch ); return $ret; } } ###获取链接内容(不存在file_get_contents() 时使用curl方法)
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-10-php-simple-methods/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-10-09-firefox-mason/">Firefox域名重定向插件——Mason</a>
  </h1>
  <time datetime="2015-10-09T00:00:00Z" class="post-date">Fri, Oct 9, 2015</time>
  工具： Mason 0.3.7.9.18 https://addons.mozilla.org/zh-CN/firefox/addon/mason/
描述：Fonts.googleapis.com 包含地址：https?://fonts.googleapis.com 重定向：http://&gt;*^https?://fonts.googleapis.com&gt;*http://fonts.useso.com
描述：Ajax.googleapis.com 包含地址：https?://ajax.googleapis.com 重定向：http://&gt;*^https?://ajax.googleapis.com&gt;*http://ajax.useso.com
描述：Themes.googleusercontent.com 包含地址：https?://themes.googleusercontent.com 重定向：http://&gt;*^https?://themes.googleusercontent.com&gt;*http://google-themes.lug.ustc.edu.cn
描述：Fonts.gstatic.com 包含地址：https?://fonts.gstatic.com 重定向：http://&gt;*^https?://fonts.gstatic.com&gt;*fonts-gstatic.lug.ustc.edu.cn
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-09-php-singleton-pattern/">PHP设计模式之单例模式</a>
  </h1>
  <time datetime="2015-10-09T00:00:00Z" class="post-date">Fri, Oct 9, 2015</time>
  单例模式（职责模式）：
简单的说，一个对象（在学习设计模式之前，需要比较了解面向对象思想）只负责一个特定的任务；
单例类：
1、构造函数需要标记为private（访问控制：防止外部代码使用new操作符创建对象），单例类不能在其他类中实例化，只能被其自身实例化；
2、拥有一个保存类的实例的静态成员变量
3、拥有一个访问这个实例的公共的静态方法（常用getInstance()方法进行实例化单例类，通过instanceof操作符可以检测到类是否已经被实例化）
另外，需要创建__clone()方法防止对象被复制（克隆）
为什么要使用PHP单例模式？
1、php的应用主要在于数据库应用, 所以一个应用中会存在大量的数据库操作, 使用单例模式, 则可以避免大量的new 操作消耗的资源。
2、如果系统中需要有一个类来全局控制某些配置信息, 那么使用单例模式可以很方便的实现. 这个可以参看ZF的FrontController部分。
3、在一次页面请求中, 便于进行调试, 因为所有的代码(例如数据库操作类db)都集中在一个类中, 我们可以在类中设置钩子, 输出日志，从而避免到处var_dump, echo。
代码实现：
&lt;?php /* * 设计模式之单例模式 * $_instance必须声明为静态的私有变量 * 构造函数和析构函数必须声明为私有,防止外部程序new * 类从而失去单例模式的意义 * getInstance()方法必须设置为公有的,必须调用此方法 * 以返回实例的一个引用 * ::操作符只能访问静态变量和静态函数 * new对象都会消耗内存 * 使用场景:最常用的地方是数据库连接。 * 使用单例模式生成一个对象后， * 该对象可以被其它众多对象所使用。 */ class Danli { //保存类实例的静态成员变量 private static $_instance; //private标记的构造方法 private function __construct(){ echo 'This is a Constructed method;'; } //创建__clone方法防止对象被复制克隆 public function __clone(){ trigger_error('Clone is not allow!
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-10-09-php-singleton-pattern/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-09-21-phpexcel/">PHPExcel类库的各种使用方法总结</a>
  </h1>
  <time datetime="2015-09-21T00:00:00Z" class="post-date">Mon, Sep 21, 2015</time>
  导入PHPExcel类库
include 'PHPExcel.php'; include 'PHPExcel/Writer/Excel2007.php'; //或者include 'PHPExcel/Writer/Excel5.php'; 用于输出.xls的 创建一个excel
$objPHPExcel = new PHPExcel(); 保存excel—2007格式
$objWriter = new PHPExcel_Writer_Excel2007($objPHPExcel); //或者$objWriter = new PHPExcel_Writer_Excel5($objPHPExcel); 非2007格式 $objWriter-&gt;save(&quot;xxx.xlsx&quot;); 直接输出到浏览器
$objWriter = new PHPExcel_Writer_Excel5($objPHPExcel); header(&quot;Pragma: public&quot;); header(&quot;Expires: 0″); header(&quot;Cache-Control:must-revalidate, post-check=0, pre-check=0″); header(&quot;Content-Type:application/force-download&quot;); header(&quot;Content-Type:application/vnd.ms-execl&quot;); header(&quot;Content-Type:application/octet-stream&quot;); header(&quot;Content-Type:application/download&quot;);; header('Content-Disposition:attachment;filename=&quot;resume.xls&quot;'); header(&quot;Content-Transfer-Encoding:binary&quot;); $objWriter-&gt;save('php://output'); ——————————————————————————————————————–
设置excel的属性：
//创建人 $objPHPExcel-&gt;getProperties()-&gt;setCreator(&quot;Maarten Balliauw&quot;); //最后修改人 $objPHPExcel-&gt;getProperties()-&gt;setLastModifiedBy(&quot;Maarten Balliauw&quot;); //标题 $objPHPExcel-&gt;getProperties()-&gt;setTitle(&quot;Office 2007 XLSX Test Document&quot;); //题目 $objPHPExcel-&gt;getProperties()-&gt;setSubject(&quot;Office 2007 XLSX Test Document&quot;); //描述 $objPHPExcel-&gt;getProperties()-&gt;setDescription(&quot;Test document for Office 2007 XLSX, generated using PHP classes.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2015-09-21-phpexcel/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/laravel/2015-09-01-laravel-build/">【laravel学习笔记】一、安装</a>
  </h1>
  <time datetime="2015-09-11T00:00:00Z" class="post-date">Fri, Sep 11, 2015</time>
  Windows下安装 一、安装前的准备工作 1. PHP环境配置 2. 安装Composer 二、安装laravel 三、配置本地虚拟域名 参考这里：
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/laravel/2015-09-11-laravel-route-controller-view/">【laravel学习笔记】二、路由、控制器及视图简介</a>
  </h1>
  <time datetime="2015-09-11T00:00:00Z" class="post-date">Fri, Sep 11, 2015</time>
  ##路由 Laravel应用的 大多数路由都将在 app/Http/routes.php 中定义，大多数基本的 Laravel 路由都只接受一个 URI 和 一个 闭包(Closure) 参数。下面是一个简单的GET路由：
Route::get('/', 'WelcomeController@index'); Route : 声明一个路由 get : 定义一个GET路由，除get外，还有post、put、delete路由; / : URL路径 WelcomeController@index : 控制器@方法 该路由是用户访问根目录 / 时，执行控制器WelcomeController中的index方法。
##控制器 上面路由调用控制器 app/Http/Controllers/WelcomeController.php中的index()方法：
&lt;?php namespace App\Http\Controllers; class WelcomeController extends Controller { public function index(){ return view('welcome'); } } 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-09-01-git-do/">git常用的一些命令</a>
  </h1>
  <time datetime="2015-09-01T00:00:00Z" class="post-date">Tue, Sep 1, 2015</time>
  查看状态 $ git status 添加修改 $ git add . 提交修改 $ git commit -m &#34;...&#34; 自动追踪文件，包括你已经手动删除的，状态为Deleted的文件 $ git add -u $ git rm .../... -r -f $ git checkout . $ git commit -m &#34;...&#34; $ git push origin master 发布文章 rake post title=&#34;文章标题&#34; rake page name=&#34;页面名称.md&#34; rake page name=&#34;pages/页面名称.md&#34; 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-08-31-linux-5/">Linux中cp直接覆盖不提示的方法</a>
  </h1>
  <time datetime="2015-08-31T00:00:00Z" class="post-date">Mon, Aug 31, 2015</time>
  cp覆盖时，无论加什么参数-f之类的还是提示是否覆盖，这在大量cp覆盖操作的时候是不能忍受的。
把a目录下的文件复制到b目录
cp –r a/* b
执行上面的命令时，b存在的每个文件都会提示是否覆盖;
cp –r –f a/* b
执行上面的命令时，b存在的每个文件都不再会提示;
这是我们希望的理想状态，但是有时加了-f了，怎么还会有提示呢？原来一些服务器会默认增加别名 alias cp=&lsquo;cp -i&rsquo;，当你执行cp时，其实执行的是cp –i。
在终端执行alias就可以看出来了。
[root@devdb ~]# alias
alias cp=&lsquo;cp -i&rsquo;
可以这样解决
[root@devdb ~]# vi ~/.bashrc
在alias cp=&lsquo;cp -i&rsquo;前加上&quot;#&ldquo;注释掉这行，：wq!保存推出，然后重新登陆就可以了。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2015-08-20-div-float/">解决子级float浮动父级无高度没有自适应问题</a>
  </h1>
  <time datetime="2015-08-20T00:00:00Z" class="post-date">Thu, Aug 20, 2015</time>
  当在对象内的盒子使用了float后，导致对象本身不能被撑开自适应高度，这个是由于浮动产生原因。
####方法一：clear:both 清除浮动 ####方法二：对父级样式加overflow样式 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-03-19-linux-vi-editor/">linux之vi编辑器命令使用</a>
  </h1>
  <time datetime="2015-04-03T00:00:00Z" class="post-date">Fri, Apr 3, 2015</time>
  高级一些的编辑器，都会包含宏功能，vim当然不能缺少了，在vim中使用宏是非常方便的：
:qx 开始记录宏，并将结果存入寄存器x q 退出记录模式 @x 播放记录在x寄存器中的宏命令 稍微解释一下，当在normal模式下输入:qx后，你对文本的所有编辑动作将会被记录下来，再次输入q即退出了记录模 式，然后输入@x对刚才记录下来的命令进行重复，此命令后可跟数字，表示要重复多少次，比如@x20，可以重复20次。这个在文本的批处理中是非常有用的。 同时编辑多个文件 在vim众多的插件中，有一个叫minibuffer的插件，就是下面所说的标签页功能了，可以支持同时编辑多个文件。 ##标签命令
:tabe fn 在一个新的标签页中编辑文件fn gt 切换到下一个标签页 gT 切换到上一个标签页 :tabr 切换到第一个标签页 :tabl 切换到最后一个标签页 :tabm [N] 把当前tab移动到第N个tab之后 对，正如你所想象的那样，跟eclipse, ue等的标签页是一个意思！ ##窗口命令 ctrl+w s 水平分割窗口 ctrl+w w 切换窗口 ctrl+w q 退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口) ctrl+w v 垂直分割窗口 ##其他 vim在保存之前不会对文件做实际的修改，只是加载到缓冲区中，对文件的编辑其实是对缓冲区的编辑，直到:w时才会存入物理文件。 :e file 把file加载到新的缓冲区中 :bn 跳转到下一个缓冲区 :bd 删除缓冲区(关闭文件) :sp fn 分割窗口，并将fn加载到新的窗口中 ##退出编辑器 :w 将缓冲区写入文件，即保存修改 :wq 保存修改并退出 :x 保存修改并退出 :q 退出，如果对缓冲区进行过修改，则会提示 :q! 强制退出，放弃修改 ##查找替换 /pattern 向后搜索字符串pattern ?pattern 向前搜索字符串pattern n 下一个匹配(如果是/搜索，则是向下的下一个，?
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-03-19-linux-vi-editor/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/bootstrap/2015-03-26-bootstrap/">bootstrap笔记</a>
  </h1>
  <time datetime="2015-03-26T00:00:00Z" class="post-date">Thu, Mar 26, 2015</time>
  ##简介
##基本页面HTML：[demo戳这里][1]
&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.2/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ##顶部导航栏 ###Static navbar
&lt;nav class=&quot;navbar navbar-default navbar-static-top&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbar&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;navbar&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Project name&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-header&quot;&gt;Nav header&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/bootstrap/2015-03-26-bootstrap/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-03-19-linux-1/">linux批量替换字符串</a>
  </h1>
  <time datetime="2015-03-19T00:00:00Z" class="post-date">Thu, Mar 19, 2015</time>
  ##批量替换文件夹下全部文件中某字符串XXXX为YYYY
sed -i &quot;s/XXXX/YYYY/g&quot; `grep XXXX -rl /www/../..` 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-03-19-linux-2/">Linux服务器间文件传输</a>
  </h1>
  <time datetime="2015-03-19T00:00:00Z" class="post-date">Thu, Mar 19, 2015</time>
  ##Linux服务器间文件传输 不同的Linux之间copy文件常用有3种方法：
第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。
第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。
第三种就是利用scp命令来进行文件复制。
1、将服务器上的目录下载到当前登录的服务器的指定目录： scp -P 端口号 -r 用户名@服务器IP:/目录名 本地目录名
使用实例： scp -P 端口号 -r root@192.168.1.240:/zsk/hollykm /home/hollykm 实现将linux 服务器192.168.1.240上/zsk/hollykm 目录复制到用户当前登录服务器的 /home/hollykm 目录下。 www.2cto.com
备注：SSH 端口默认的是 22，如果修改了，则更改为修改后的端口号；如果端口号默认是22 ，则可以不用写 -P。 其中-r 是循环复制。
2、将服务器上的文件下载到当前登录的服务器的指定目录下，并命名：
使用实例： scp root@192.168.1.240:/zsk/hollykm/test.txt /home/test_copy.txt
将linux 服务器192.168.1.240上/zsk/hollykm/test.txt 文件复制到登录服务器的/home/下并重命名为 test_copy.txt
可能有用的几个参数 :
-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 .
-C 使能压缩选项 .
-P 选择端口 . 注意 -p 已经被 rcp 使用 .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-03-19-linux-2/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2015-03-19-linux-tar-zip/">打包/压缩目录</a>
  </h1>
  <time datetime="2015-03-19T00:00:00Z" class="post-date">Thu, Mar 19, 2015</time>
  ##打包/压缩目录
范例一：将整个 /etc 目录下的文件全部打包成为 /tmp/etc.tar
[root@linux ~]# tar -cvf /tmp/etc.tar /etc &lt;==仅打包，不压缩！ [root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc &lt;==打包后，以 gzip 压缩 [root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc &lt;==打包后，以 bzip2 压缩 将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下
[root@linux ~]# cd /usr/local/src [root@linux src]# tar -zxvf /tmp/etc.tar.gz 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-02-28-sublime-text/">Sublime Text Snippets(代码片段)功能</a>
  </h1>
  <time datetime="2015-02-28T00:00:00Z" class="post-date">Sat, Feb 28, 2015</time>
  我们在编写代码的时候，总会遇到一些需要反复使用的代码片段。这时候就需要反复的复制和黏贴，大大影响效率。我们利用Sublime Text的snippet功能，就能很好的解决这一问题。通俗的讲，就是把我们常用的代码分别保存起啦，然后通过插件的形式来反复调用。
创建方法：Tools &gt; New Snippet 弹出如下示例代码：
&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ Hello, ${1:this} is a ${2:snippet}. ]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt; &lt;/snippet&gt; 完整的结构和说明：
&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ 你需要插入的代码片段${1:name} ]]&gt;&lt;/content&gt; &lt;!-- 可选：快捷键，利用Tab自动补全代码的功能 --&gt; &lt;tabTrigger&gt;html5&lt;/tabTrigger&gt; &lt;!-- 可选：使用范围，不填写代表对所有文件有效。附：source.css和test.html分别对应不同文件。 --&gt; &lt;scope&gt;source.python&lt;/scope&gt; &lt;!-- 可选：在snippet菜单中的显示说明（支持中文）。如果不定义，菜单则显示当前文件的文件名。 --&gt; &lt;description&gt;My Fancy Snippet&lt;/description&gt; &lt;/snippet&gt; ${1:name}表示代码插入后，光标所停留的位置，可同时插入多个。其中:name为自定义参数（可选）。 ${2}表示代码插入后，按Tab键，光标会根据顺序跳转到相应位置（以此类推）。
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-02-28-sublime-text/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2015-01-01-scroller/">自定义滚动条样式</a>
  </h1>
  <time datetime="2015-02-09T00:00:00Z" class="post-date">Mon, Feb 9, 2015</time>
  其中的一中方案是使用jQuery插件，jquery-custom-content-scroller。使用插件的好处是显而易见的，但是坏处也多得去了。要是您想了解jQuery-custom-content-scroller的具体使用方法，请移步到：http://manos.malihu.gr/jquery-custom-content-scroller/
##webkit内核浏览器 /* 设置滚动条的样式 / ::-webkit-scrollbar { height: 10px; width: 10px; } / 滚动槽 / ::-webkit-scrollbar-track { -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); } / 滚动条滑块 */ ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5); border-radius: 10px; } ::-webkit-scrollbar-thumb:window-inactive { background: rgba(255,0,0,0.4); } ##IE浏览器 scrollbar-arrow-color: #f4ae21; /图6,三角箭头的颜色/ scrollbar-face-color: #333; /图5,立体滚动条的颜色/ scrollbar-3dlight-color: #666; /图1,立体滚动条亮边的颜色/ scrollbar-highlight-color: #666; /图2,滚动条空白部分的颜色/ scrollbar-shadow-color: #999; /图3,立体滚动条阴影的颜色/ scrollbar-darkshadow-color: #666; /图4,立体滚动条强阴影的颜色/ scrollbar-track-color: #666; /图7,立体滚动条背景颜色/ scrollbar-base-color:#f8f8f8; /滚动条的基本颜色/ Cursor:url(mouse.cur); /自定义个性鼠标/ [1]: {{ page.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2015-01-01-scroller/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-01-30-markdown/">标准的markdown格式练习</a>
  </h1>
  <time datetime="2015-01-30T00:00:00Z" class="post-date">Fri, Jan 30, 2015</time>
  ##First sublime text预览markdown效果: Ctrl+Alt+O
####文字 try something 我是斜体文本哦 我是粗文本哦 我有短代码框哦 ####引用文本
this is a simple dialogure if you can see this article successful this is a simple dialogure if you can see this article successful this is a simple dialogure if you can see this article successful this is a simple dialogure if you can see this article successful
####链接 [sdgdf][1] [1]: http://www.baidu.com &ldquo;baidu&rdquo;
####图片 ![Aaron Swartz][p1] [p1]: http://upload-images.jianshu.io/upload_images/188518-fcb1ab53d4af226f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &ldquo;Aaron Swartz&rdquo;
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-01-30-markdown/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-01-01-github-blog/">使用Github Pages建独立博客</a>
  </h1>
  <time datetime="2015-01-19T00:00:00Z" class="post-date">Mon, Jan 19, 2015</time>
  Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。
Github Pages有以下几个优点：
当然他也有缺点：
使用Jekyll模板系统，相当于静态页发布，适合博客，文档介绍等。 动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。 基于Git，很多东西需要动手，不像Wordpress有强大的后台 大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。
购买、绑定独立域名 虽说Godaddy曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。
域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。
流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在BeiYuu也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。
我们选择DNSPod的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：
域名的配置部分完成，跪谢方校长。
配置和使用Github Git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本[Git中文教程][4]。
要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。Windows版的下载地址在这里：http://code.google.com/p/msysgit/downloads/list。其他系统的安装也可以参考官方的[安装教程][5]。
下载安装客户端之后，各个系统的配置就类似了，我们使用windows作为例子，Linux和Mac与此类似。
在Windows下，打开Git Bash，其他系统下面则打开终端（Terminal）： ###1、检查SSH keys的设置 首先我们需要检查你电脑上现有的ssh key：
$ cd ~/.ssh 如果显示“No such file or directory”，跳到第三步，否则继续。
###2、备份和移除原来的ssh key设置： 因为已经存在key文件，所以需要备份旧的数据并删除：
$ ls config	id_rsa	id_rsa.pub	known_hosts $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* ###3、生成新的SSH Key： 输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。
$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-01-01-github-blog/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/2015-01-01-jekyll/">安装Jekyll</a>
  </h1>
  <time datetime="2015-01-19T00:00:00Z" class="post-date">Mon, Jan 19, 2015</time>
  ##安装ruby环境 安装Jekyll，下载地址：[http://rubyinstaller.org/downloads/][]
##下载DevKit并解压 DevKit 是 windows 平台下编译和使用本地 C/C++ 扩展包的工具。它就是用来模拟 Linux 平 台下的 make,gcc,sh 来进行编译。但是这个方法目前仅支持通过 RubyInstaller 安装的 Ruby 。 下载地址：http://rubyinstaller.org/downloads/
##git下安装Devkit
###3.1
git下（cmd下各种问题）进入Devkit解压的目录，执行以下命令
####3.1.1
$ Ruby dk.rb init $ Ruby dk.rb install 如果config.yml有报错，找到这个文件，按里面的说明添加两行路径
- E:\Ruby21-x64 - E:\Ruby21-x64 ####3.1.2
$ ruby -v 出现版本号，证明安装成功
###3.2
$ Gem install Jekyll 这一步安装Jekyll，由于天朝网络的关系，可能会出现Unable to download data的错误，解决方法：
$ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org （请确保只有 ruby.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/2015-01-01-jekyll/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2014-01-01-css/">css笔记</a>
  </h1>
  <time datetime="2014-01-01T00:00:00Z" class="post-date">Wed, Jan 1, 2014</time>
  背景渐变色：
background-image: linear-gradient(to right, #fff, #000 100%);
currentColor
table-css
&lt;table class=&quot;table&quot; cellspacing=&quot;0&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width=&quot;10%&quot;&gt;序号&lt;/th&gt; &lt;th width=&quot;20%&quot;&gt;游戏&lt;/th&gt; &lt;th width=&quot;20%&quot;&gt;区服&lt;/th&gt; &lt;th width=&quot;20%&quot;&gt;卡号&lt;/th&gt; &lt;th width=&quot;30%&quot;&gt;领取时间&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;volist name=&quot;mycard_list&quot; id=&quot;vo&quot; key=&quot;k&quot;&gt; &lt;tr&gt; &lt;td&gt;{$k}&lt;/td&gt; &lt;td&gt;{$vo.gamename}&lt;/td&gt; &lt;td&gt;{$vo.servername}&lt;/td&gt; &lt;td&gt;{$vo.card_info}&lt;/td&gt; &lt;td&gt;{$vo.get_time|date=&quot;Y-m-d H:i:s&quot;,###}&lt;/td&gt; &lt;/tr&gt; &lt;/volist&gt; &lt;/tbody&gt; &lt;/table&gt; .table {width: 100%;margin-bottom: 20px;text-align: center;vertical-align: middle;} .table th,.table td {line-height: 20px;padding: 15px 20px;text-align: center;font-size: 14px;border: 0 none;} .table thead th {background-color: #dfdfdf;color: #fff;} .table tbody td {background-color: #fff;color: #666;} .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/htmlcss/2014-01-01-css/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/jquery/2014-01-01-jquery/">jQuery笔记</a>
  </h1>
  <time datetime="2014-01-01T00:00:00Z" class="post-date">Wed, Jan 1, 2014</time>
  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/javascript/2014-01-01-js/">js笔记</a>
  </h1>
  <time datetime="2014-01-01T00:00:00Z" class="post-date">Wed, Jan 1, 2014</time>
  ##js简介
##点击全屏
var fullscreen=function(){ elem=document.body; if(elem.webkitRequestFullScreen){ elem.webkitRequestFullScreen(); }else if(elem.mozRequestFullScreen){ elem.mozRequestFullScreen(); }else if(elem.requestFullScreen){ elem.requestFullscreen(); }else{ //浏览器不支持全屏API或已被禁用 } } var exitFullscreen=function(){ var elem=document; if(elem.webkitCancelFullScreen){ elem.webkitCancelFullScreen(); }else if(elem.mozCancelFullScreen){ elem.mozCancelFullScreen(); }else if(elem.cancelFullScreen){ elem.cancelFullScreen(); }else if(elem.exitFullscreen){ elem.exitFullscreen(); }else{ //浏览器不支持全屏API或已被禁用 } } 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/php/2014-01-01-php/">php知识笔记</a>
  </h1>
  <time datetime="2014-01-01T00:00:00Z" class="post-date">Wed, Jan 1, 2014</time>
  ##写入文件
$fp = fopen($_SERVER['DOCUMENT_ROOT'].&quot;/xxx.txt&quot;,&quot;a+&quot;); fwrite($fp,date(&quot;Y-m-d H:i:s&quot;,time()).&quot;\r\n&quot;); fclose($fp); ##查找文件下所有文件名
$str = ''; $dir = &quot;../Tpl/&quot;; $preg2 = '/[A-Za-z]/'; if (is_dir ( $dir )) { if ($dh = opendir ( $dir )) { while ( ($file = readdir ( $dh )) !== false ) { if (preg_match ( $preg2, $file )) { $zt = ''; if ($info ['theme'] == $file) { $zt = 'selected'; } $str .= '&lt;option value=' . $file . ' ' .
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/php/2014-01-01-php/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/thinkphp/2014-01-01-thinkphp/">ThinkPHP笔记</a>
  </h1>
  <time datetime="2014-01-01T00:00:00Z" class="post-date">Wed, Jan 1, 2014</time>
  简介 ThinkPHP 是一个免费开源的，快速、简单的面向对象的 轻量级PHP开发框架 ，创立于2006年初，遵循Apache2开源协议发布，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。ThinkPHP从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简的代码的同时，也注重易用性。并且拥有众多的原创功能和特性，在社区团队的积极参与下，在易用性、扩展性和性能方面不断优化和改进，已经成长为国内最领先和最具影响力的WEB应用开发框架，众多的典型案例确保可以稳定用于商业以及门户级的开发。
全面的WEB开发特性支持 最新的ThinkPHP为WEB应用开发提供了强有力的支持，这些支持包括：
MVC支持-基于多层模型（M）、视图（V）、控制器（C）的设计模式 ORM支持-提供了全功能和高性能的ORM支持，支持大部分数据库 模板引擎支持-内置了高性能的基于标签库和XML标签的编译型模板引擎 RESTFul支持-REST模式提供了RESTFul支持，为你打造全新的URL设计和访问体验 云引擎支持-提供了对新浪SAE平台和百度BAE平台的强力支持，具备“横跨性”和“平滑性”，支持本地化开发和调试以及部署切换，让你轻松过渡，打造全新的开发体验。 CLI支持-支持基于命令行的应用开发 AMF支持-支持Flex开发和Flash通讯，打造互联网富应用 PHPRPC支持-提供基于PHPRpc的WEBService解决方案 MongoDb支持-提供NoSQL的支持 缓存支持-提供了包括文件、数据库、Memcache、Xcache、Redis等多种类型的缓存支持 大道至简的开发理念 ThinkPHP从诞生以来一直秉承大道至简的开发理念，无论从底层实现还是应用开发，我们都倡导用最少的代码完成相同的功能，正是由于对简单的执着和代码的修炼，让我们长期保持出色的性能和极速的开发体验。在主流PHP开发框架的评测数据中表现卓越，简单和快速开发是我们不变的宗旨。
安全性 框架在系统层面提供了众多的安全特性，确保你的网站和产品安全无忧。这些特性包括：
XSS安全防护 表单自动验证 强制数据类型转换 输入数据过滤 表单令牌验证 防SQL注入 图像上传检测 商业友好的开源协议 ThinkPHP遵循Apache2开源协议发布。Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再作为开源或商业软件发布。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://gongvirgil.github.io/Blog/post/%E6%8A%80%E6%9C%AF/linux/2014-01-01-linux/">各种常用的Linux操作命令</a>
  </h1>
  <time datetime="2014-01-01T00:00:00Z" class="post-date">Wed, Jan 1, 2014</time>
  ##简单速记命令：
查看时间： date 更新Internet时间： ntpdate time.windows.com 重启httpd:	service httpd restart 复制文件夹下文件 cp -r /home/aaa/* /home/sss 修改权限 chmod -R 777 /home/aaa/* 删除文件 rm -rf /home/aaa/* 查看当前规则：cat /etc/sysconfig/iptables ##复杂操作笔记：
替换字符串: [戳这里][1] linux服务器之间文件传输：[戳这里][2] 打包/压缩目录：[戳这里][3] vi编辑器使用命令：[戳这里][4] ##查找目录下的所有文件中是否含有某个字符串
find .| xargs grep -ri &quot;XXXX&quot; ##查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名
find .| xargs grep -ri &quot;XXXX&quot; -l service iptables stop service iptables start ##crontab定时执行任务
编辑：crontab -e
列出：crontab -l
退出编辑：ctrl+c
保存：:wp
分 时 日 月 周 命令 0 */3 * * * wget http://www.
  
  <div class="read-more-link">
    <a href="/Blog/post/%E6%8A%80%E6%9C%AF/linux/2014-01-01-linux/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
